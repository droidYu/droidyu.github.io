<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin笔记 09 - 委托</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-09/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-09/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/bd/2c/bd5668ecfb84e324f6239e7f24ddcf2c.jpg?wh=2000x1160"></p><h1 id="委托类"><a href="#委托类" class="headerlink" title="委托类"></a>委托类</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDB</span></span>() : DB &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;save to sql&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenDaoDB</span></span>() : DB &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;save to GreenDao&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//               参数  通过 by 将接口实现委托给 db </span></span><br><span class="line"><span class="comment">//                ↓            ↓</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniversalDB</span></span>(db: DB) : DB <span class="keyword">by</span> db</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    UniversalDB(SqlDB()).save()</span><br><span class="line">    UniversalDB(GreenDaoDB()).save()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">save to sql</span></span><br><span class="line"><span class="comment">save to GreenDao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>等价于以下 Java 代码</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> UniversalDB implements <span class="keyword">DB</span> &#123;</span><br><span class="line">    <span class="keyword">DB</span> <span class="keyword">db</span>;</span><br><span class="line">    public UniversalDB(<span class="keyword">DB</span> <span class="keyword">db</span>) &#123; this.<span class="keyword">db</span> = <span class="keyword">db</span>; &#125;</span><br><span class="line">             <span class="comment">//  手动重写接口，将 save 委托给 db.save()</span></span><br><span class="line">    @Override<span class="comment">//            ↓</span></span><br><span class="line">    public void <span class="keyword">save</span>() &#123; <span class="keyword">db</span>.<span class="keyword">save</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 的委托类提供了语法层面的委托模式</p><p>通过这个 by 关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。</p><h1 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h1><p>Kotlin“委托类”委托的是接口方法，而“委托属性”委托的，则是属性的 getter、setter。</p><h2 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h2><h3 id="将属性-A-委托给属性-B"><a href="#将属性-A-委托给属性-B" class="headerlink" title="将属性 A 委托给属性 B"></a>将属性 A 委托给属性 B</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Item &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">count</span>: Int = 0</span><br><span class="line">    <span class="comment">//              ①  ②</span></span><br><span class="line">    <span class="comment">//              ↓   ↓</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">total</span>: Int <span class="keyword">by</span> ::<span class="keyword">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 近似逻辑，实际上，底层会生成一个Item$total$2类型的delegate来实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Item &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">count</span>: Int = 0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">total</span>: Int</span><br><span class="line">        <span class="built_in">get</span>() = <span class="keyword">count</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span>(value: Int) &#123;</span><br><span class="line">            <span class="keyword">count</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性，其实对我们软件版本之间的兼容很有帮助。假设 Item 是服务端接口的返回数据，1.0 版本的时候，我们的 Item 当中只 count 这一个变量：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.0 版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="keyword">count</span>: Int = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而到了 2.0 版本的时候，我们需要将 count 修改成 total，这时候问题就出现了，如果我们直接将 count 修改成 total，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量 total，然后将其委托给 count，这样的话，2.0 的用户访问 total，而 1.0 的用户访问原来的 count，由于它们是委托关系，也不必担心数值不一致的问题。</p><h3 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//            定义懒加载委托</span></span><br><span class="line"><span class="comment">//               ↓   ↓</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span>: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    request()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;执行网络请求&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;网络数据&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">开始</span><br><span class="line">执行网络请求</span><br><span class="line">网络数据</span><br><span class="line">网络数据</span><br></pre></td></tr></table></figure><p>懒加载委托的源代码，你会发现，它其实是一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (mode) &#123;</span><br><span class="line">        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2><p>自定义委托，我们必须遵循 Kotlin 制定的规则</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringDelegate</span></span>(<span class="keyword">private</span> <span class="keyword">var</span> s: String = <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//     ①                           ②                              ③</span></span><br><span class="line"><span class="comment">//     ↓                            ↓                               ↓</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//      ①                          ②                                     ③ </span></span><br><span class="line"><span class="comment">//      ↓                           ↓                                      ↓</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            s = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      ②</span></span><br><span class="line"><span class="comment">//      ↓</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span> </span>&#123;</span><br><span class="line"><span class="comment">//               ③</span></span><br><span class="line"><span class="comment">//               ↓     </span></span><br><span class="line">    <span class="keyword">var</span> text: String <span class="keyword">by</span> StringDelegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，看到两处注释①对应的代码，对于 var 修饰的属性，我们必须要有 getValue、setValue 这两个方法，同时，这两个方法必须有 operator 关键字修饰。</li><li>其次，看到三处注释②对应的代码，我们的 text 属性是处于 Owner 这个类当中的，因此 getValue、setValue 这两个方法中的 thisRef 的类型，必须要是 Owner，或者是 Owner 的父类。也就是说，我们将 thisRef 的类型改为 Any 也是可以的。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将 thisRef 的类型定义为“Any?”。</li><li>最后，看到三处注释③对应的代码，由于我们的 text 属性是 String 类型的，为了实现对它的委托，getValue 的返回值类型，以及 setValue 的参数类型，都必须是 String 类型或者是它的父类。大部分情况下，这三处的类型都应该是一致的。</li></ul><p>这样的写法实在很繁琐，也可以借助 Kotlin 提供的 ReadWriteProperty、ReadOnlyProperty 这两个接口，来自定义委托。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要为 val 属性定义委托，我们就去实现 ReadOnlyProperty 这个接口；如果我们需要为 var 属性定义委托，我们就去实现 ReadWriteProperty 这个接口。这样做的好处是，通过实现接口的方式，IntelliJ 可以帮我们自动生成 override 的 getValue、setValue 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringDelegate</span></span>(<span class="keyword">private</span> <span class="keyword">var</span> s: String = <span class="string">&quot;Hello&quot;</span>): ReadWriteProperty&lt;Owner, String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Owner</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        s = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提供委托（provideDelegate）"><a href="#提供委托（provideDelegate）" class="headerlink" title="提供委托（provideDelegate）"></a>提供委托（provideDelegate）</h2><p>假设我们现在有一个这样的需求：我们希望 StringDelegate(s: String) 传入的初始值 s，可以根据委托属性的名字的变化而变化。我们应该怎么做？</p><p>实际上，要想在属性委托之前再做一些额外的判断工作，我们可以使用 provideDelegate 来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDelegator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        thisRef: <span class="type">Owner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        prop: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ReadWriteProperty&lt;Owner, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (prop.name.contains(<span class="string">&quot;log&quot;</span>)) &#123;</span><br><span class="line">            StringDelegate(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            StringDelegate(<span class="string">&quot;normal&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> normalText: String <span class="keyword">by</span> SmartDelegator()</span><br><span class="line">    <span class="keyword">var</span> logText: String <span class="keyword">by</span> SmartDelegator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> owner = Owner()</span><br><span class="line">    println(owner.normalText)</span><br><span class="line">    println(owner.logText)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">normal</span><br><span class="line">log</span><br></pre></td></tr></table></figure><p>可以看到，为了在委托属性的同时进行一些额外的逻辑判断，我们使用创建了一个新的 SmartDelegator，通过它的成员方法 provideDelegate 嵌套了一层，在这个方法当中，我们进行了一些逻辑判断，然后再把属性委托给 StringDelegate。</p><p>如此一来，通过 provideDelegate 这样的方式，我们不仅可以嵌套 Delegator，还可以根据不同的逻辑派发不同的 Delegator。</p><h1 id="实战与思考"><a href="#实战与思考" class="headerlink" title="实战与思考"></a>实战与思考</h1><h2 id="案例-1：属性可见性封装"><a href="#案例-1：属性可见性封装" class="headerlink" title="案例 1：属性可见性封装"></a>案例 1：属性可见性封装</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt; <span class="keyword">by</span> ::_data</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _data.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了两个变量，一个变量是公开的“data”，它的类型是 List，这是 Kotlin 当中不可修改的 List，它是没有 add、remove 等方法的。</p><p>接着，我们通过委托语法，将 data 的 getter 委托给了 _data 这个属性。而 _data 这个属性的类型是 MutableList，这是 Kotlin 当中的可变集合，它是有 add、remove 方法的。由于它是 private 修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的 List，因此类的外部只能访问数据。</p><h2 id="案例-2：数据与-View-的绑定"><a href="#案例-2：数据与-View-的绑定" class="headerlink" title="案例 2：数据与 View 的绑定"></a>案例 2：数据与 View 的绑定</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> TextView.<span class="title">provideDelegate</span><span class="params">(value: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">object</span> : ReadWriteProperty&lt;Any?, String?&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String? = text</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        text = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">val textView = findViewById&lt;textView&gt;(R.id.textView)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line">var message: <span class="keyword">String</span>? by textView</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line">textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">println</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line">message = <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">println</span>(textView.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><h2 id="案例-3：ViewModel-委托"><a href="#案例-3：ViewModel-委托" class="headerlink" title="案例 3：ViewModel 委托"></a>案例 3：ViewModel 委托</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainViewModel: MainViewModel <span class="keyword">by</span> viewModels()</span><br></pre></td></tr></table></figure><p>我们先来看看 viewModels() 是如何实现的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> ComponentActivity.<span class="title">viewModels</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> factoryProducer: (() -&gt; <span class="type">Factory</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Lazy&lt;VM&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> factoryPromise = factoryProducer ?: &#123;</span><br><span class="line">        defaultViewModelProviderFactory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ViewModelLazy(VM::<span class="class"><span class="keyword">class</span>, <span class="type">&#123; viewModelStore &#125;</span>, <span class="type">factoryPromise)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lazy</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>viewModels() 是 Activity 的一个扩展函数。也是因为这个原因，我们才可以直接在 Activity 当中直接调用 viewModels() 这个方法。</p><p>另外，我们注意到，viewModels() 这个方法的返回值类型是 Lazy，那么，它是如何实现委托功能的呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Lazy<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br></pre></td></tr></table></figure><p>Lazy 类在外部还定义了一个扩展函数 getValue()，这样，我们的只读属性的委托就实现了。而 Android 官方这样的代码设计，就再一次体现了职责划分、关注点分离的原则。Lazy 类只包含核心的成员，其他附属功能，以扩展的形式在 Lazy 外部提供。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>委托类，委托的是接口的方法，它在语法层面支持了“委托模式”。</li><li>委托属性，委托的是属性的 getter、setter。虽然它的核心理念很简单，但我们借助这个特性可以设计出非常复杂的代码。</li><li>另外，Kotlin 官方还提供了几种标准的属性委托，它们分别是：两个属性之间的直接委托、by lazy 懒加载委托、Delegates.observable 观察者委托，以及 by map 映射委托；</li><li>两个属性之间的直接委托，它是 Kotlin 1.4 提供的新特性，它在属性版本更新、可变性封装上，有着很大的用处；</li><li>by lazy 懒加载委托，可以让我们灵活地使用懒加载，它一共有三种线程同步模式，默认情况下，它就是线程安全的；Android 当中的 viewModels() 这个扩展函数在它的内部实现的懒加载委托，从而实现了功能强大的 ViewModel；</li><li>除了标准委托以外，Kotlin 可以让我们开发者自定义委托。自定义委托，我们需要遵循 Kotlin 提供的一套语法规范，只要符合这套语法规范，就没问题；</li><li>在自定义委托的时候，如果我们有灵活的需求时，可以使用 provideDelegate 来动态调整委托逻辑。<h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记（附加）</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-other/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-other/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p><img src="https://static001.geekbang.org/resource/image/12/6a/12fe0504cd5329b2634a6b3746c0yy6a.jpg?wh=1920x1013"></p><p>命令式编程，其实就是最常见的编程方式：在编程的时候，我们需要告诉计算机每一步具体都要干什么。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式，或者说“声明式”的代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fun</span> fp() = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ul><li>它只需要声明我们想要什么，而不必关心底层如何实现。</li><li>代码更加简洁，可读性更高。</li></ul><p>3.0 版本的词频统计程序，其实并没有完全发挥出 Kotlin 函数式编程的优势，因为其中的“getWordCount()”“mapToList()”都是我们自己实现的。事实上，我们完全可以借助 Kotlin 标准库函数来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processText</span><span class="params">(text: <span class="type">String</span>)</span></span>: List&lt;WordFreq&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">        .clean()</span><br><span class="line">        .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .filter &#123; it != <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">        .groupBy &#123; it &#125;</span><br><span class="line">        .map &#123; WordFreq(it.key, it.value.size) &#125;</span><br><span class="line">        .sortedByDescending &#123; it.frequency &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="到底什么是函数式编程？"><a href="#到底什么是函数式编程？" class="headerlink" title="到底什么是函数式编程？"></a>到底什么是函数式编程？</h2><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><ul><li>函数可以独立于类之外，这就是 Kotlin 的顶层函数；</li><li>函数可以作为参数和返回值，这就是高阶函数和 Lambda；</li><li>函数可以像变量一样，这就是函数的引用；</li><li>当函数的功能更加强大以后，我们就可以几乎可以做到：只使用函数来解决所有编程的问题。<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3></li><li>函数不应该有副作用。所谓副作用，就是“对函数作用域以外的数据进行修改”，而这就引出了函数式的不变性。在函数式编程当中，我们不应该修改任何变量，当我们需要修改变量的时候，我们要创建一份新的拷贝再做修改，然后再使用它（这里，你是不是马上就想到了数据类的 copy 方法呢？）。</li><li>无副作用的函数，它具有幂等性，换句话说就是：函数调用一次和调用 N 次，它们的效果是等价的。</li><li>无副作用的函数，它具有引用透明的特性。</li><li>无副作用的函数，它具有无状态的特性。</li></ul><h2 id="实战：函数式的循环"><a href="#实战：函数式的循环" class="headerlink" title="实战：函数式的循环"></a>实战：函数式的循环</h2><p>for 循环，是命令式编程当中最典型的语句</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        result += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅只使用函数，我们该如何实现这样的功能呢？答案其实很简单，那就是递归。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用尾递归。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的开发工作中，这种方式是不推荐的，毕竟它太绕了，对吧？如果要在工作中实现类似的需求，我们使用 Kotlin 集合操作符一行代码就能搞定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reduce</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.10</span>).reduce &#123; acc, i -&gt; acc + i &#125; <span class="comment">// 结果 55</span></span><br></pre></td></tr></table></figure><p>Kotlin 还为我们提供了另一个更简单的操作符，也就是 sum：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.10</span>).sum() <span class="comment">// 结果 55</span></span><br></pre></td></tr></table></figure><h1 id="表达式思维"><a href="#表达式思维" class="headerlink" title="表达式思维"></a>表达式思维</h1><h1 id="不变性思维"><a href="#不变性思维" class="headerlink" title="不变性思维"></a>不变性思维</h1><h1 id="空安全思维"><a href="#空安全思维" class="headerlink" title="空安全思维"></a>空安全思维</h1><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 08 - inline</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-08/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-08/</url>
      
        <content type="html"><![CDATA[<h1 id="高阶函数实现原理"><a href="#高阶函数实现原理" class="headerlink" title="高阶函数实现原理"></a>高阶函数实现原理</h1><p>由于 Kotlin 兼容 Java 1.6，因此 JVM 是不懂什么是高阶函数的，我们的高阶函数最终一定会被编译器转换成 JVM 能够理解的格式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HigherOrderExample.kt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    foo&#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译成 Java 后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HigherOrderExampleKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Function0 block)</span> </span>&#123;</span><br><span class="line">      block.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span></span><br><span class="line">      foo((Function0)(<span class="keyword">new</span> Function0() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 高阶函数当中的函数类型参数，变成了 Function0，而 main() 函数当中的高阶函数调用，也变成了“匿名内部类”的调用方式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="inline原理"><a href="#inline原理" class="headerlink" title="inline原理"></a>inline原理</h1><p>使用 inline 优化过的高阶函数会是什么样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HigherOrderInlineExample.kt</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多了一个关键字</span></span><br><span class="line"><span class="comment">   ↓                                    */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">fooInline</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    fooInline&#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的 Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HigherOrderInlineExampleKt</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 没有变化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fooInline</span><span class="params">(Function0 block)</span> </span>&#123;</span><br><span class="line">      block.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 差别在这里</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> i = i + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/de/c8/de4c7c3ee9b93c60ca93ab4074db78c8.png?wh=1920x1080"><br>inline 的作用其实就是将 inline 函数当中的代码拷贝到调用处。</p><p>是否使用 inline，main() 函数会有以下两个区别：</p><ul><li>在不使用 inline 的情况下，我们的 main() 方法当中，需要调用 foo() 这个函数，这里多了一次函数调用的开销。</li><li>在不使用 inline 的情况下，调用 foo() 函数时，还创建了“Function0”的匿名内部类对象，这也是额外的开销。</li></ul><h1 id="inline-的局限性"><a href="#inline-的局限性" class="headerlink" title="inline 的局限性"></a>inline 的局限性</h1><p>Kotlin 官方只建议我们将 inline 用于修饰高阶函数。对于普通的 Kotlin 函数，如果我们用 inline 去修饰它，IntelliJ 会对我们发出警告。</p><p><img src="https://static001.geekbang.org/resource/image/31/4c/3113667bb87e2fe9929a704a0a14a24c.png?wh=1708x736"></p><p>inline 的作用其实就是将 inline 函数当中的代码拷贝到调用处。由于 processText() 是公开的，因此它会从外部被调用，这意味着它的代码会被拷贝到外部去执行，而 getWordCount() 和 mapToList() 这两个函数却无法在外部被访问。这就是导致编译器报错的原因。</p><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 07 - 高阶函数</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-07/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-07/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/45/3e/45e23ce48a64711943366fec784af23e.jpg?wh=1920x1171"></p><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//         (Int,  Int) -&gt;Float 这就是 add 函数的类型</span></span><br><span class="line"><span class="comment">//           ↑     ↑      ↑</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Float</span> &#123; <span class="keyword">return</span> (a+b).toFloat() &#125;</span><br></pre></td></tr></table></figure><p>将函数的“参数类型”和“返回值类型”抽象出来后，就得到了“函数类型”。<br>(Int, Int) -&gt;Float 就代表了参数类型是两个 Int，返回值类型为 Float 的函数类型。</p><h1 id="函数的引用"><a href="#函数的引用" class="headerlink" title="函数的引用"></a>函数的引用</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数赋值给变量                    函数引用</span></span><br><span class="line"><span class="comment">//    ↑                              ↑</span></span><br><span class="line"><span class="keyword">val</span> function: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Float</span> = ::add</span><br></pre></td></tr></table></figure><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数是将函数用作参数或返回值的函数。<br>如果我们将 Android 里点击事件的监听用 Kotlin 来实现的话，它其实就是一个典型的高阶函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                      函数作为参数的高阶函数</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h1 id="SAM-转换"><a href="#SAM-转换" class="headerlink" title="SAM 转换"></a>SAM 转换</h1><p>SAM 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，SAM 代表着只有一个抽象方法的接口。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><h1 id="Lambda-表达式引发的-8-种写法"><a href="#Lambda-表达式引发的-8-种写法" class="headerlink" title="Lambda 表达式引发的 8 种写法"></a>Lambda 表达式引发的 8 种写法</h1><h2 id="第-1-种写法"><a href="#第-1-种写法" class="headerlink" title="第 1 种写法"></a>第 1 种写法</h2><p>这是原始代码，它的本质是用 object 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第-2-种写法"><a href="#第-2-种写法" class="headerlink" title="第 2 种写法"></a>第 2 种写法</h2><p>在这种情况下，object 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 Lambda 表达式了，因此它里面 override 的方法也要跟着删掉：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">View</span>.OnClickListener &#123; v: <span class="keyword">View</span>? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的View.OnClickListener被称为 SAM Constructor（SAM 构造器），它是编译器为我们生成的。</p><h2 id="第-3-种写法"><a href="#第-3-种写法" class="headerlink" title="第 3 种写法"></a>第 3 种写法</h2><p>由于 Kotlin 的 Lambda 表达式是不需要 SAM Constructor 的，所以它也可以被删掉：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image<span class="selector-class">.setOnClickListener</span>(&#123; v: View? -&gt;</span><br><span class="line">    <span class="built_in">gotoPreview</span>(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第-4-种写法"><a href="#第-4-种写法" class="headerlink" title="第 4 种写法"></a>第 4 种写法</h2><p>由于 Kotlin 支持类型推导，所以 View 可以被删掉：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">image.setOnClickListener</span>(&#123; <span class="variable">v</span> -&gt;</span><br><span class="line">    <span class="function"><span class="title">gotoPreview</span>(<span class="variable">v</span>)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第-5-种写法"><a href="#第-5-种写法" class="headerlink" title="第 5 种写法"></a>第 5 种写法</h2><p>当 Kotlin Lambda 表达式只有一个参数的时候，它可以被写成 it：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; <span class="literal">it</span> -&gt;</span><br><span class="line">    gotoPreview(<span class="literal">it</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第-6-种写法"><a href="#第-6-种写法" class="headerlink" title="第 6 种写法"></a>第 6 种写法</h2><p>Kotlin Lambda 的 it 是可以被省略的：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">image.setOnClickListener</span>(&#123;</span><br><span class="line">    <span class="function"><span class="title">gotoPreview</span>(<span class="variable">it</span>)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第-7-种写法"><a href="#第-7-种写法" class="headerlink" title="第 7 种写法"></a>第 7 种写法</h2><p>当 Kotlin Lambda 作为函数的最后一个参数时，Lambda 可以被挪到外面：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.set<span class="constructor">OnClickListener()</span> &#123;</span><br><span class="line">    goto<span class="constructor">Preview(<span class="params">it</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第-8-种写法"><a href="#第-8-种写法" class="headerlink" title="第 8 种写法"></a>第 8 种写法</h2><p>当 Kotlin 只有一个 Lambda 作为函数参数时，() 可以被省略：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">image.setOnClickListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">gotoPreview</span>(<span class="variable">it</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画显示演变过程：<br><img src="https://static001.geekbang.org/resource/image/e4/bf/e441323968c0c061898257fd06db37bf.gif?wh=1080x608"><br>函数类型、高阶函数以及 Lambda 表达式三者之间的关系：<br><img src="https://static001.geekbang.org/resource/image/ec/71/ecf85d05f6fdc5ea2d015a61d7e64771.png?wh=1920x914"></p><h1 id="难点：带接收者的函数类型"><a href="#难点：带接收者的函数类型" class="headerlink" title="难点：带接收者的函数类型"></a>难点：带接收者的函数类型</h1><p><img src="https://static001.geekbang.org/resource/image/9a/04/9acd54ac08d88c94ca52336a576b3304.png?wh=1890x1156"><br>以apply函数为例<br>不用 apply：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="keyword">user</span> != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    username.text = <span class="keyword">user</span>.name</span><br><span class="line">    website.text = <span class="keyword">user</span>.blog</span><br><span class="line">    image.<span class="built_in">set</span>OnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">user</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 apply：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user?.<span class="built_in">apply</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    username.<span class="built_in">text</span> = <span class="built_in">name</span></span><br><span class="line">    website.<span class="built_in">text</span> = blog</span><br><span class="line">    <span class="built_in">image</span>.setOnClickListener &#123; gotoImagePreviewActivity(this) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反推apply函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply 肯定是个函数，所以有 ()，只是被省略了</span></span><br><span class="line">user?.apply() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 肯定是在 () 里面</span></span><br><span class="line">user?.apply(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 gotoImagePreviewActivity(this) 里的 this 代表了 user</span></span><br><span class="line"><span class="comment">// 所以 user 应该是 apply 函数的一个参数，而且参数名为：this</span></span><br><span class="line">user?.apply(&#123; <span class="keyword">this</span>: User -&gt; ... &#125;)</span><br></pre></td></tr></table></figure><p>apply 其实是接收了一个 Lambda 表达式：{ this: User -&gt; … }。那么现在，我们就尝试来实现这个 apply 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(self: <span class="type">User</span>, block: (<span class="type">self</span>: <span class="type">User</span>) -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line">    block(self)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply(self = user) &#123; self: User -&gt;</span><br><span class="line">            username.text = self.name</span><br><span class="line">            website.text = self.blog</span><br><span class="line">            image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin 里面的函数形参是不允许被命名为 this 的，因此我这里用的是 self。另外，这里我们自己写出来的 apply，仍然还要通过 self.name 这样的方式来访问成员变量，但 Kotlin 的语言设计者能做到这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           改为this             改为this</span></span><br><span class="line"><span class="comment">//               ↓                    ↓ </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(this: <span class="type">User</span>, block: (<span class="type">this</span>: <span class="type">User</span>) -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line"><span class="comment">//    这里还要传参数</span></span><br><span class="line"><span class="comment">//         ↓ </span></span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply(<span class="keyword">this</span> = user) &#123; <span class="keyword">this</span>: User -&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//               this 可以省略</span></span><br><span class="line"><span class="comment">//                   ↓ </span></span><br><span class="line">    username.text = <span class="keyword">this</span>.name</span><br><span class="line">    website.text = blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子能看到，我们反推的 apply 实现会比较繁琐：需要我们传入 this：user?.apply(this = user)。需要我们自己调用：block(this)。因此，Kotlin 就引入了带接收者的函数类型，可以简化 apply 的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//              带接收者的函数类型</span></span><br><span class="line"><span class="comment">//                     ↓  </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">apply</span><span class="params">(block: <span class="type">User</span>.() -&gt; <span class="type">Unit</span>)</span></span>: User&#123;</span><br><span class="line"><span class="comment">//  不用再传this</span></span><br><span class="line"><span class="comment">//       ↓ </span></span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user?.apply &#123; <span class="keyword">this</span>: User -&gt;</span><br><span class="line"><span class="comment">//               this 可以省略</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line">    username.text = <span class="keyword">this</span>.name</span><br><span class="line">    website.text = <span class="keyword">this</span>.blog</span><br><span class="line">    image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 apply 方法是不是看起来就像是在 User 里，增加了一个成员方法 apply()？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> blog: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 成员方法可以通过 this 访问成员变量</span></span><br><span class="line">        username.text = <span class="keyword">this</span>.name</span><br><span class="line">        website.text = <span class="keyword">this</span>.blog</span><br><span class="line">        image.setOnClickListener &#123; gotoImagePreviewActivity(<span class="keyword">this</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，从外表上看，带接收者的函数类型，就等价于成员方法。但从本质上讲，它仍是通过编译器注入 this 来实现的。</p><p>那么，带接收者的函数类型，可看成扩展函数，从语法层面讲，扩展函数就相当于成员函数。</p><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 06 - 扩展</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-06/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-06/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/b4/10/b4a3ce7c3e0b2228161faa4769618a10.jpg?wh=1999x1333"></p><h1 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"><span class="keyword">package</span> com.boycoder.chapter06</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②      ③            ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个扩展函数的方法体当中，this 都是可以省略的。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>反编译后的 Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtKt</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ①</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Character <span class="title">lastElement</span><span class="params">(String $<span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">      CharSequence var1 = (CharSequence)$<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (var1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>  var1.charAt(var1.length() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String msg = <span class="string">&quot;Hello Wolrd&quot;</span>;</span><br><span class="line">  <span class="comment">//                        ②</span></span><br><span class="line">  <span class="comment">//                        ↓</span></span><br><span class="line">  Character last = ExtKt.lastElement(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的 Java 代码几乎和我们前面扩展函数的一模一样。<br><img src="https://static001.geekbang.org/resource/image/2a/ed/2a38487b61ec06e437c1425b2a69ffed.png?wh=1920x752"><br>Kotlin 的扩展表面上看起来是为一个类扩展了新的成员，但是本质上，它还是静态方法。</p><h1 id="扩展的能力边界"><a href="#扩展的能力边界" class="headerlink" title="扩展的能力边界"></a>扩展的能力边界</h1><h2 id="扩展能做什么？"><a href="#扩展能做什么？" class="headerlink" title="扩展能做什么？"></a>扩展能做什么？</h2><p>它最主要的用途，就是用来取代 Java 当中的各种工具类，比如 StringUtils、DateUtils 等等。</p><p>所有 Java 工具类能做的事情，Kotlin 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><h2 id="扩展不能做什么？"><a href="#扩展不能做什么？" class="headerlink" title="扩展不能做什么？"></a>扩展不能做什么？</h2><ul><li>Kotlin 扩展不是真正的类成员，因此它无法被它的子类重写。</li><li>扩展属性无法存储状态。</li><li>扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="主动使用扩展，通过它来优化软件架构。"><a href="#主动使用扩展，通过它来优化软件架构。" class="headerlink" title="主动使用扩展，通过它来优化软件架构。"></a>主动使用扩展，通过它来优化软件架构。</h2><p>对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的String.kt与Strings.kt。</p><h2 id="被动使用扩展，提升可读性与开发效率。"><a href="#被动使用扩展，提升可读性与开发效率。" class="headerlink" title="被动使用扩展，提升可读性与开发效率。"></a>被动使用扩展，提升可读性与开发效率。</h2><p>当我们无法修改外部的 SDK 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如 view.updateMargin()。</p><p>示例：通过 updateMargin() 这个扩展函数，可以大大简化 Android 当中的 margin 更新。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : ViewGroup.LayoutParams&gt;</span> View.<span class="title">updateLayoutParams</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> params = layoutParams <span class="keyword">as</span> T</span><br><span class="line">    block(params)</span><br><span class="line">    layoutParams = params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">updateMargin</span><span class="params">(left: <span class="type">Int</span>? = <span class="literal">null</span>, top: <span class="type">Int</span>? = <span class="literal">null</span>, right: <span class="type">Int</span>? = <span class="literal">null</span>, bottom: <span class="type">Int</span>? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    (layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123; param -&gt;</span><br><span class="line">        updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; &#123;</span><br><span class="line">            left?.let &#123;</span><br><span class="line">                marginStart = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right?.let &#123;</span><br><span class="line">                marginEnd = right</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top?.let &#123;</span><br><span class="line">                topMargin = top</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bottom?.let &#123;</span><br><span class="line">                bottomMargin = bottom</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.updateMargin(top = <span class="number">100</span>, bottom = <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>Kotlin 的扩展，从语法角度来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从作用域角度来看，分为顶层扩展和类内扩展。</li><li>从本质上来看，扩展函数和扩展属性，它们都是 Java 静态方法，与 Java 当中的工具类别无二致。对比 Java 工具类，扩展最大的优势就在于，IDE 可以为我们提供代码补全功能。</li><li>从能力的角度来看，Kotlin 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从使用场景的角度来看，Kotlin 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ul><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 05 - object</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-05/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-05/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/cc/67/cc75cc62f08d1b4f2e604630499f8b67.jpg?wh=1920x1260"></p><p>object 关键字，有三种迥然不同的语义，分别可以定义：</p><ul><li>匿名内部类；</li><li>单例模式；</li><li>伴生对象。</li></ul><p>Kotlin 的设计者认为，这三种语义本质上都是在定义一个类的同时还创建了对象。在这样的情况下，与其分别定义三种不同的关键字，还不如将它们统一成 object 关键字。</p><h1 id="object：匿名内部类"><a href="#object：匿名内部类" class="headerlink" title="object：匿名内部类"></a>object：匿名内部类</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，匿名内部类还有一个特殊之处，就是我们在使用 object 定义匿名内部类的时候，其实还可以在继承一个抽象类的同时，来实现多个接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">findMan</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个匿名内部类，在继承了Man类的同时，还实现了A、B两个接口</span></span><br><span class="line">    <span class="keyword">val</span> item = <span class="keyword">object</span> : Man(), A, B&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findMan</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法，在 Java 当中其实是不被支持的。</p><h1 id="object：单例模式"><a href="#object：单例模式" class="headerlink" title="object：单例模式"></a>object：单例模式</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译对应的 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserManager INSTANCE; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      UserManager var0 = <span class="keyword">new</span> UserManager();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">UserManager</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 编译器会将其转换成静态代码块的单例模式。因为static{}代码块当中的代码，由虚拟机保证它只会被执行一次，因此，它在保证了线程安全的前提下，同时也保证我们的 INSTANCE 只会被初始化一次。<br>这种方式定义的单例模式，虽然具有简洁的优点，但同时也存在两个缺点。</p><ul><li><strong>不支持懒加载。</strong>这个问题很容易解决，我们在后面会提到。</li><li><strong>不支持传参构造单例。</strong>举个例子，在 Android 开发当中，很多情况下我们都需要用到 Context 作为上下文。另外有的时候，在单例创建时可能也需要 Context 才可以创建，那么如果这时候单纯只有 object 创建的单例，就无法满足需求了。</li></ul><h1 id="object：伴生对象"><a href="#object：伴生对象" class="headerlink" title="object：伴生对象"></a>object：伴生对象</h1><h2 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h2><p>先来看看 object 定义单例的一种特殊情况，看看它是如何演变成“伴生对象”的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译成 Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Person.InnerSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">InnerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         Person.InnerSingleton var0 = <span class="keyword">new</span> Person.InnerSingleton();</span><br><span class="line">         INSTANCE = var0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用“@JvmStatic”，实现类似 Java 静态方法的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略其他相同代码</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 foo() 方法的调用，不管是 Kotlin 还是 Java，它们的调用方式都会变成一样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.InnerSingleton.foo()</span><br></pre></td></tr></table></figure><p>上面的静态内部类“InnerSingleton”看起来有点多余，我们平时在 Java 当中写的静态方法，不应该是只有一个层级吗？如何实现？</p><p>加一个 companion 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">//  改动在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> InnerSingleton &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Person.InnerSingleton InnerSingleton = <span class="keyword">new</span> Person.InnerSingleton((DefaultConstructorMarker)<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意这里</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      InnerSingleton.foo();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">InnerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">InnerSingleton</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被挪到外部的静态方法 foo()，它最终还是调用了单例 InnerSingleton 的成员方法 foo()，所以它只是做了一层转接而已。</p><p>普通的 object 单例，演变出了嵌套的单例；嵌套的单例，演变出了伴生对象。</p><p>换个说法：嵌套单例，是 object 单例的一种特殊情况；伴生对象，是嵌套单例的一种特殊情况。</p><h2 id="伴生对象的实战应用"><a href="#伴生对象的实战应用" class="headerlink" title="伴生对象的实战应用"></a>伴生对象的实战应用</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  私有的构造函数，外部无法调用</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>)</span></span>: User? &#123;</span><br><span class="line">            <span class="comment">// 统一检查，比如敏感词过滤</span></span><br><span class="line">            <span class="keyword">return</span> User(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另外-4-种单例模式的写法"><a href="#另外-4-种单例模式的写法" class="headerlink" title="另外 4 种单例模式的写法"></a>另外 4 种单例模式的写法</h3><h4 id="借助懒加载委托"><a href="#借助懒加载委托" class="headerlink" title="借助懒加载委托"></a>借助懒加载委托</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserManager &#123;</span><br><span class="line">    <span class="comment">// 对外暴露的 user</span></span><br><span class="line">    <span class="keyword">val</span> user <span class="keyword">by</span> lazy &#123; loadUser() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="comment">// 从网络或者数据库加载数据</span></span><br><span class="line">        <span class="keyword">return</span> User.create(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伴生对象-Double-Check"><a href="#伴生对象-Double-Check" class="headerlink" title="伴生对象 Double Check"></a>伴生对象 Double Check</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: UserManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(name: <span class="type">String</span>)</span></span>: UserManager =</span><br><span class="line">            <span class="comment">// 第一次判空</span></span><br><span class="line">            INSTANCE?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次判空</span></span><br><span class="line">                INSTANCE?:UserManager(name).also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">UserManager.getInstance(<span class="string">&quot;Tom&quot;</span>)</span><br></pre></td></tr></table></figure><p>定义了一个伴生对象，然后在它的内部，定义了一个 INSTANCE，它是 private 的，这样就保证了它无法直接被外部访问。同时它还被注解“@Volatile”修饰了，这可以保证 INSTANCE 的可见性，而 getInstance() 方法当中的 synchronized，保证了 INSTANCE 的原子性。因此，这种方案还是线程安全的。</p><p>以上的实现方式仍然存在一个问题：不同的单例当中，我们必须反复写 Double Check 的逻辑</p><h4 id="抽象类模板"><a href="#抽象类模板" class="headerlink" title="抽象类模板"></a>抽象类模板</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ①                          ②                      </span></span><br><span class="line"><span class="comment">//  ↓                           ↓                       </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       ③</span></span><br><span class="line">    <span class="comment">//                       ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//            ④</span></span><br><span class="line">            <span class="comment">//            ↓</span></span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释①：abstract 关键字，代表了我们定义的 BaseSingleton 是一个抽象类。我们以后要实现单例类，就只需要继承这个 BaseSingleton 即可。</li><li>注释②：in P, out T 是 Kotlin 当中的泛型，P 和 T 分别代表了 getInstance() 的参数类型和返回值类型。注意，这里的 P 和 T，是在具体的单例子类当中才需要去实现的。如果你完全不知道泛型是什么东西，可以先看看泛型的介绍，我们在第 10 讲会详细介绍 Kotlin 泛型。</li><li>注释③：creator(param: P): T 是 instance 构造器，它是一个抽象方法，需要我们在具体的单例子类当中实现此方法。</li><li>注释④：creator(param) 是对 instance 构造器的调用。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="comment">//               ①                  ②</span></span><br><span class="line">    <span class="comment">//               ↓                   ↓</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, PersonManager&gt;() &#123;</span><br><span class="line">    <span class="comment">//                  ③</span></span><br><span class="line">    <span class="comment">//                  ↓ </span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: PersonManager = PersonManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : BaseSingleton&lt;String, UserManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: UserManager = UserManager(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释①：companion object : BaseSingleton，由于伴生对象本质上还是嵌套类，也就是说，它仍然是一个类，那么它就具备类的特性“继承其他的类”。因此，我们让伴生对象继承 BaseSingleton 这个抽象类。</li><li>注释②：String, PersonManager，这是我们传入泛型的参数 P、T 对应的实际类型，分别代表了 creator() 的“参数类型”和“返回值类型”。</li><li>注释③：override fun creator，我们在子类当中实现了 creator() 这个抽象方法。<h4 id="接口模板（不推荐）"><a href="#接口模板（不推荐）" class="headerlink" title="接口模板（不推荐）"></a>接口模板（不推荐）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISingleton</span>&lt;<span class="type">P, T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">var</span> instance: T?</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">P</span>)</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(p: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(p).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>缺陷：</p><ul><li><strong>instance 无法使用 private 修饰。</strong> 这是接口特性规定的，而这并不符合单例的规范。正常情况下的单例模式，我们内部的 instance 必须是 private 的，这是为了防止它被外部直接修改。</li><li><strong>instance 无法使用 @Volatile 修饰。</strong> 这也是受限于接口的特性，这会引发多线程同步的问题。</li></ul><p>除了 ISingleton 接口有这样的问题，我们在实现 ISingleton 接口的类当中，也会有类似的问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: ISingleton&lt;String, Singleton&gt; &#123;</span><br><span class="line">        <span class="comment">//  ①      ②</span></span><br><span class="line">        <span class="comment">//  ↓       ↓</span></span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">override</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">creator</span><span class="params">(param: <span class="type">String</span>)</span></span>: Singleton = Singleton(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释①：@Volatile，这个注解虽然可以在实现的时候添加，但实现方可能会忘记，这会导致隐患。</li><li>注释②：我们在实现 instance 的时候，仍然无法使用 private 来修饰。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kotlin 的匿名内部类和 Java 的类似，只不过它多了一个功能：<strong>匿名内部类可以在继承一个抽象类的同时还实现多个接口。</strong></p><p>object 的单例和伴生对象，这两种语义从表面上看是没有任何联系的。<strong>“单例”演变出了“嵌套单例”，而“嵌套单例”演变出了“伴生对象”。</strong></p><p>借助 Kotlin 伴生对象这个语法，研究了伴生对象的实战应用，比如可以实现<strong>工厂模式、懒加载 + 带参数的单例模式。</strong></p><p>单例模式使用场景：</p><ul><li>如果我们的单例占用内存很小，并且对内存不敏感，不需要传参，直接使用 object 定义的单例即可。</li><li>如果我们的单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，我们可以使用 object 搭配 by lazy 懒加载。</li><li>如果我们的工程很简单，只有一两个单例场景，同时我们有懒加载需求，并且 getInstance() 需要传参，我们可以直接手写 Double Check。</li><li>如果我们的工程规模大，对内存敏感，单例场景比较多，那我们就很有必要使用抽象类模板 BaseSingleton 了。</li></ul><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 03 - Kotlin原理</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-03/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-03/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/02/34/02702d48a28378817ed1598849bfbb34.jpg?wh=1920x912"></p><h1 id="Kotlin-的编译流程"><a href="#Kotlin-的编译流程" class="headerlink" title="Kotlin 的编译流程"></a>Kotlin 的编译流程</h1><p>Kotlin 代码经过编译后，最终会变成 Java 字节码。Kotlin 和 Java 能够兼容的原因也在于此，Java 和 Kotlin 本质上是在用同一种语言进行沟通。<br><img src="https://static001.geekbang.org/resource/image/d6/0f/d67630808ee59a642b93d955ae8fa60f.jpg?wh=1920x1480"></p><h1 id="如何研究-Kotlin？"><a href="#如何研究-Kotlin？" class="headerlink" title="如何研究 Kotlin？"></a>如何研究 Kotlin？</h1><p>将 Kotlin 转换成字节码后，再将字节码反编译成等价的 Java 代码。<br><img src="https://static001.geekbang.org/resource/image/fd/24/fdfbcf0b8a293acc91b5e435c99cb324.jpg?wh=2000x1074"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;Hello world.&quot;</span>) <span class="comment">/*</span></span><br><span class="line"><span class="comment">          编译</span></span><br><span class="line"><span class="comment">           ↓            */</span>    </span><br><span class="line">LDC <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">INVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         反编译</span></span><br><span class="line"><span class="comment">           ↓            */</span></span><br><span class="line">String var0 = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(var0);</span><br></pre></td></tr></table></figure><p>Android Studio 操作：Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode ，Decompile</p><h1 id="Kotlin-里到底有没有“原始类型”？"><a href="#Kotlin-里到底有没有“原始类型”？" class="headerlink" title="Kotlin 里到底有没有“原始类型”？"></a>Kotlin 里到底有没有“原始类型”？</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 val 定义可为空、不可为空的Long，并且赋值</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Long</span> = <span class="number">1L</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = <span class="number">2L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空、不可为空的Long，并且赋值</span></span><br><span class="line"><span class="keyword">var</span> c: <span class="built_in">Long</span> = <span class="number">3L</span></span><br><span class="line"><span class="keyword">var</span> d: <span class="built_in">Long</span>? = <span class="number">4L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空的Long，先赋值，然后改为null</span></span><br><span class="line"><span class="keyword">var</span> e: <span class="built_in">Long</span>? = <span class="number">5L</span></span><br><span class="line">e = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 val 定义可为空的Long，直接赋值null</span></span><br><span class="line"><span class="keyword">val</span> f: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 定义可为空的Long，先赋值null，然后赋值数字</span></span><br><span class="line"><span class="keyword">var</span> g: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">g = <span class="number">6L</span></span><br></pre></td></tr></table></figure><p>Java 反编译代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反编译后的 Java 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> c = <span class="number">3L</span>;</span><br><span class="line"><span class="keyword">long</span> d = <span class="number">4L</span>;</span><br><span class="line"></span><br><span class="line">Long e = <span class="number">5L</span>;</span><br><span class="line">e = (Long)<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Long f = (Long)<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Long g = (Long)<span class="keyword">null</span>;</span><br><span class="line">g = <span class="number">6L</span>;</span><br></pre></td></tr></table></figure><p>最终 a、b、c、d 被 Kotlin 转换成了 Java 的原始类型 long；而 e、f、g 被转换成了 Java 里的包装类型 Long。</p><p>Kotlin 对基础类型的转换规则：</p><ul><li>只要基础类型的变量可能为空，那么这个变量就会被转换成 Java 的包装类型。</li><li>反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成 Java 的原始类型。</li></ul><h1 id="接口语法的局限性"><a href="#接口语法的局限性" class="headerlink" title="接口语法的局限性"></a>接口语法的局限性</h1><p><img src="https://static001.geekbang.org/resource/image/88/b9/886dc2d7a5d5ee47934c1003447412b9.png?wh=1770x1230"></p><ul><li>箭头①，代表 Kotlin 接口属性，实际上会被当中接口方法来看待。</li><li>箭头②，代表 Kotlin 接口默认实现，实际上还是一个普通的方法。</li><li>箭头③，代表 Kotlin 接口默认实现的逻辑是被放在 DefaultImpls 当中的，它成了静态内部类当中的一个静态方法 DefaultImpls.walk()。</li><li>箭头④，代表 Kotlin 接口的实现类必须要重写接口当中的属性，同时，它仍然还是一个方法。</li><li>箭头⑤，即使 Kotlin 里的 Man 类没有实现 walk() 方法，但是从 Java 的角度看，它仍然存在 walk() 方法，并且，walk() 方法将它的执行流程转交给了 DefaultImpls.walk()，并将 this 传入了进去。这样，接口默认方法的逻辑就可以成功执行了。</li></ul><p>Kotlin 接口当中的属性，在它被真正实现之前，本质上并不是一个真正的属性。因此，Kotlin 接口当中的属性，它既不能真正存储任何状态，也不能被赋予初始值，因为它本质上还是一个接口方法。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kotlin 代码，最终都会被 Kotlin 编译器进行一次统一的翻译，把它们变成 Java 能理解的格式。正是因为 Kotlin 编译器在背后做的这些翻译工作，才可以让我们写出的 Kotlin 代码更加简洁、更加安全。</p><ul><li>类型推导，我们写 Kotlin 代码的时候省略的变量类型，最终被编译器补充回来了。</li><li>原始类型，虽然 Kotlin 没有原始类型，但编译器会根据每一个变量的可空性将它们转换成“原始类型”或者“包装类型”。</li><li>字符串模板，编译器最终会将它们转换成 Java 拼接的形式。</li><li>when 表达式，编译器最终会将它们转换成类似 switch case 的语句。</li><li>类默认 public，Kotlin 当中被我们省略掉 public，最终会被编译器补充。</li><li>嵌套类默认 static，我们在 Kotlin 当中的嵌套类，默认会被添加 static 关键字，将其变成静态内部类，防止不必要的内存泄漏。</li><li>数据类，Kotlin 当中简单的一行代码“data class Person(val name: String, val age: Int)”，编译器帮我们自动生成很多方法：getter()、setter()、equals()、hashCode()、toString()、componentN()、copy()。</li></ul><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 02 - 面向对象</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-02/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-02/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/21/bf/21080a921b3aa73872bfd55f7c1cddbf.jpg?wh=1920x911"></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>Kotlin 定义的类，在默认情况下是 public 的</p><h2 id="自定义属性-getter"><a href="#自定义属性-getter" class="headerlink" title="自定义属性 getter"></a>自定义属性 getter</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult</span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"><span class="comment">//        ↑</span></span><br><span class="line"><span class="comment">//    这就是isAdult属性的getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓 getter，就是<strong>获取属性值的方法</strong></p><p>如果 get() 方法内部的逻辑比较复杂，我们仍然可以像正常函数那样，带上花括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// do something else</span></span><br><span class="line">            <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，编译器的自动类型推导就会失效了，所以我们要为 isAdult 属性增加明确的类型：Boolean。</p><p>判断一个人是否为成年人，我们只需要判断 age 这个属性即可，为什么还要引入一个新的属性 isAdult 呢？</p><ul><li>实际上，这里涉及到 Java 到 Kotlin 的一种思想转变。让我们来详细分解上面的问题：首先，从语法的角度上来说，是否为成年人，本来就是属于人身上的一种属性。我们在代码当中将其定义为属性，更符合直觉。而如果我们要给 Person 增加一个行为，比如 walk，那么这种情况下定义一个新的方法就是非常合适的。</li><li>其次，从实现层面来看，我们确实定义了一个新的属性 isAdult，但是 Kotlin 编译器能够分析出，我们这个属性实际是根据 age 来做逻辑判断的。在这种情况下，Kotlin 编译器可以在 JVM 层面，将其优化为一个方法。</li><li>通过以上两点，我们就成功在语法层面有了一个 isAdult 属性；但是在实现层面，isAdult 仍然还是个方法。这也就意味着，isAdult 本身不会占用内存，它的性能和我们用 Java 写的方法是一样的。而这在 Java 当中是无法实现的。</li></ul><h2 id="自定义属性-setter"><a href="#自定义属性-setter" class="headerlink" title="自定义属性 setter"></a>自定义属性 setter</h2><p>所谓 setter，就是可以对属性赋值的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">//  这就是age属性的setter</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line">        <span class="keyword">set</span>(value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">            log(value)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的时候，我们不希望属性的 set 方法在外部访问，那么我们可以给 set 方法加上可见性修饰符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>(value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">            log(value)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类与继承"><a href="#抽象类与继承" class="headerlink" title="抽象类与继承"></a>抽象类与继承</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                      Java 的继承</span></span><br><span class="line"><span class="comment">//                           ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="title">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    void onCreate()&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//              Kotlin 的继承</span></span><br><span class="line"><span class="comment">//                 ↓</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有用 open 修饰的话，它是无法被继承的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>: <span class="type">Person</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 的类，默认是不允许继承的，除非这个类明确被 open 关键字修饰了。另外，对于被 open 修饰的普通类，它内部的方法和属性，默认也是不允许重写的，除非它们也被 open 修饰了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>: <span class="type">Person</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 的继承是默认开放的，Kotlin 的继承是默认封闭的。Kotlin 的这个设计非常好，这样就不会出现 Java 中“继承被滥用”的情况。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">val</span> a = name   <span class="comment">// 报错</span></span><br><span class="line">        <span class="keyword">val</span> b = foo()  <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就对应了 Java 当中的<strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的Java代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        String a = name)   <span class="comment">// 报错</span></span><br><span class="line">        <span class="keyword">int</span> b = foo()      <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 当中的普通嵌套类，它的本质是<strong>静态的</strong>。相应地，如果想在 Kotlin 当中定义一个普通的内部类，我们需要在嵌套类的前面<strong>加上 inner 关键字</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 增加了一个关键字</span></span><br><span class="line"><span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">val</span> a = name   <span class="comment">// 通过</span></span><br><span class="line">        <span class="keyword">val</span> b = foo()  <span class="comment">// 通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 的这种设计非常巧妙。如果你熟悉 Java 开发，你会知道，Java 当中的嵌套类，如果没有 static 关键字的话，它就是一个内部类，这样的<strong>内部类是会持有外部类的引用</strong>的。可是，这样的设计在 Java 当中会非常容易出现<strong>内存泄漏</strong>！而大部分 Java 开发者之所以会犯这样的错误，往往只是因为忘记加“static”关键字了。这是一个 Java 开发者默认情况下就容易犯的错。</p><p>Kotlin 则反其道而行之，在默认情况下，<strong>嵌套类变成了静态内部类</strong>，而这种情况下的嵌套类是不会持有外部类引用的。只有当我们真正需要访问外部类成员的时候，我们才会加上 inner 关键字。这样一来，默认情况下，开发者是不会犯错的，只有手动加上 inner 关键字之后，才可能会出现内存泄漏，而当我们加上 inner 之后，其实往往也就能够意识到内存泄漏的风险了。</p><p>也就是说，<strong>Kotlin 这样的设计，就将默认犯错的风险完全抹掉了</strong>！</p><h1 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h1><p>Kotlin 的接口，跟 Java 最大的差异就在于，接口的方法<strong>可以有默认实现</strong>，同时，它也<strong>可以有属性</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Behavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口内的可以有属性</span></span><br><span class="line">    <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口方法的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canWalk) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String): Behavior &#123;</span><br><span class="line">    <span class="comment">// 重写接口的属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> canWalk: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在 Java 1.8 版本当中，接口也引入了类似的特性，但由于 Kotlin 是完全兼容 Java 1.6 版本的。因此为了实现这个特性，Kotlin 编译器在背后做了一些转换。这也就意味着，它是有一定局限性的（TODO 后面会讲）。</p><h1 id="Kotlin-中的特殊类"><a href="#Kotlin-中的特殊类" class="headerlink" title="Kotlin 中的特殊类"></a>Kotlin 中的特殊类</h1><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p><strong>用于存放数据的类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 数据类当中，最少要有一个属性</span></span><br><span class="line">                   ↓</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>编译器会为数据类自动生成一些有用的方法。它们分别是：</p><ul><li>equals()；</li><li>hashCode()；</li><li>toString()；</li><li>componentN() 函数；</li><li>copy()。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tom = Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">val</span> jack = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">println(tom.equals(jack)) <span class="comment">// 输出：false</span></span><br><span class="line">println(tom.hashCode())   <span class="comment">// 输出：对应的hash code</span></span><br><span class="line">println(tom.toString())   <span class="comment">// 输出：Person(name=Tom, age=18)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (name, age) = tom     <span class="comment">// name=Tom, age=18</span></span><br><span class="line">println(<span class="string">&quot;name is <span class="variable">$name</span>, age is <span class="variable">$age</span> .&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mike = tom.copy(name = <span class="string">&quot;Mike&quot;</span>)</span><br><span class="line">println(mike)             <span class="comment">// 输出：Person(name=Mike, age=18)</span></span><br></pre></td></tr></table></figure><p>“val (name, age) = tom”这行代码，其实是使用了数据类的<strong>解构声明</strong>。这种方式，可以让我们快速通过数据类来创建一连串的变量</p><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p><strong>密封类，是更强大的枚举类</strong>,需要使用 <strong>sealed 关键字</strong></p><p>Android 开发当中，我们会经常使用密封类对数据进行封装。比如我们可以来看一个代码例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Loading</span></span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(<span class="keyword">data</span>: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> Result.Success -&gt; displaySuccessUI(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">is</span> Result.Error -&gt; showErrorMsg(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">is</span> Result.Loading -&gt; showLoading()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kotlin 语法在一些细节的良苦用心</p><ul><li>Kotlin 的类，默认是 public 的。</li><li>Kotlin 的类继承语法、接口实现语法，是完全一样的。</li><li>Kotlin 当中的类默认是对继承封闭的，类当中的成员和方法，默认也是无法被重写的。这样的设计就很好地避免了继承被滥用。</li><li>Kotlin 接口可以有成员属性，还可以有默认实现。</li><li>Kotlin 的嵌套类默认是静态的，这种设计可以防止我们无意中出现内存泄漏问题。</li><li>Kotlin 独特的数据类，在语法简洁的同时，还给我们提供了丰富的功能。</li><li>密封类，作为枚举和对象的结合体，帮助我们很好地设计数据模型，支持 when 表达式完备性。</li></ul><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记 01 - 基础语法</title>
      <link href="/Note/GeekTime/Kotlin/kotlin-note-01/"/>
      <url>/Note/GeekTime/Kotlin/kotlin-note-01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/32/67/32ab3d37cd7f9650f4cba17736305c67.jpg?wh=1920x1983"></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键字     变量类型</span></span><br><span class="line"><span class="comment"> ↓          ↓           */</span></span><br><span class="line"><span class="keyword">var</span> price: <span class="built_in">Int</span> = <span class="number">100</span>;   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ↑            ↑</span></span><br><span class="line"><span class="comment">   变量名        变量值   */</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price: <span class="built_in">Int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>Kotlin 支持<strong>类型推导</strong>，大部分情况下，我们的变量类型可以省略不写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">100</span> <span class="comment">// 默认推导类型为： Int</span></span><br></pre></td></tr></table></figure><p>我们应该尽可能避免使用 var，<strong>尽可能多地去使用 val</strong></p><ul><li>val 声明的变量，我们叫做<strong>不可变变量</strong>，它的值在初始化以后就无法再次被修改，它相当于 Java 里面的 final 变量。</li><li>var 声明的变量，我们叫做<strong>可变变量</strong>，它对应 Java 里的普通变量。</li></ul><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>在 Kotlin 语言体系当中，是<strong>没有原始类型</strong>这个概念的。这也就意味着，<strong>在 Kotlin 里，一切都是对象</strong>。</p><p>虽然 Kotlin 在语法层面摒弃了“原始类型”，但有时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？（TODO 后面会讲）<br><img src="https://pic.imgdb.cn/item/6236f4b05baa1a80ab6e0c3d.jpg"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Double</span> = <span class="number">1.</span>toDouble()</span><br></pre></td></tr></table></figure><h1 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Double</span> = <span class="literal">null</span> <span class="comment">// 编译器报错</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Double</span>? = <span class="literal">null</span> <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>由于 Kotlin 对可能为空的变量类型做了强制区分，这就意味着，“可能为空的变量”无法直接赋值给“不可为空的变量”，当然，反向赋值是没有问题的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="built_in">Double</span> = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">var</span> j: <span class="built_in">Double</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">i = j  <span class="comment">// 编译器报错</span></span><br><span class="line">j = i  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> int = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> long = <span class="number">1234567L</span></span><br><span class="line"><span class="keyword">val</span> double = <span class="number">13.14</span></span><br><span class="line"><span class="keyword">val</span> float = <span class="number">13.14F</span></span><br><span class="line"><span class="keyword">val</span> hexadecimal = <span class="number">0xAF</span></span><br><span class="line"><span class="keyword">val</span> binary = <span class="number">0b01010101</span></span><br></pre></td></tr></table></figure><ul><li>整数默认会被推导为“Int”类型；</li><li>Long 类型，我们则需要使用“L”后缀；</li><li>小数默认会被推导为“Double”，我们不需要使用“D”后缀；</li><li>Float 类型，我们需要使用“F”后缀；</li><li>使用“0x”，来代表十六进制字面量；</li><li>使用“0b”，来代表二进制字面量。</li></ul><p>Java 可以隐式转换数字类型，而 Kotlin 更推崇显式转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">long</span> j = i;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Long</span> = i <span class="comment">// 编译器报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> j: <span class="built_in">Long</span> = i.toLong() <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>Kotlin 这样设计的优势也是显而易见的，我们代码的<strong>可读性更强了，将来也更容易维护</strong>了。</p><h1 id="字符：Char"><a href="#字符：Char" class="headerlink" title="字符：Char"></a>字符：Char</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = c <span class="comment">// 编译器报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = c.toInt() <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><h1 id="字符串：String"><a href="#字符串：String" class="headerlink" title="字符串：String"></a>字符串：String</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello Kotlin!&quot;</span></span><br></pre></td></tr></table></figure><p>Kotlin 还为我们提供了非常简洁的<strong>字符串模板</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">print(<span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line"><span class="comment">/*            ↑</span></span><br><span class="line"><span class="comment">    直接在字符串中访问变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Hello Kotlin!</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Hello <span class="subst">$&#123;array.get(<span class="number">1</span>)&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment">/*            ↑</span></span><br><span class="line"><span class="comment">      复杂的变量，使用$&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Hello Kotlin!</span><br></pre></td></tr></table></figure><p>Kotlin 还新增了一个<strong>原始字符串</strong>，它定义的时候是什么格式，最终打印也会是对应的格式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       当我们的字符串有复杂的格式时</span></span><br><span class="line"><span class="string">       原始字符串非常的方便</span></span><br><span class="line"><span class="string">       因为它可以做到所见即所得。 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayInt = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> arrayString = arrayOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br></pre></td></tr></table></figure><p>Kotlin 编译器也会根据传入的参数进行类型推导。</p><p>虽然 Kotlin 的数组仍然不属于集合，但它的一些操作是跟集合统一的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Size is <span class="subst">$&#123;array.size&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;First element is <span class="subst">$&#123;array[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Size <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">First element <span class="keyword">is</span> apple</span><br></pre></td></tr></table></figure><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键字    函数名          参数类型   返回值类型</span></span><br><span class="line"><span class="comment"> ↓        ↓                ↓       ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br><span class="line">&#125;<span class="comment">/*   ↑</span></span><br><span class="line"><span class="comment">   花括号内为：函数体</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>它的函数体实际上只有一行代码。那么针对这种情况，我们其实就可以省略函数体的花括号，直接使用“=”来连接，将其变成一种类似变量赋值的函数形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: String = <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br></pre></td></tr></table></figure><p>称之为<strong>单一表达式函数</strong></p><p>由于 Kotlin 支持类型推导，我们在使用单一表达式形式的时候，返回值的类型也可以省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">helloFunction</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="string">&quot;Hello <span class="variable">$name</span> !&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(<span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>Kotlin 提供了一些新的特性，那就是命名参数，在调用函数的时候传入“形参的名字”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(name = <span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>针对参数较多的函数，我们一般会以<strong>纵向的方式排列</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>体现出了 Kotlin 命名参数的<strong>可读性</strong>与<strong>易维护性</strong>两个优势。</p><p>Kotlin 还支持<strong>参数默认值</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有默认值的参数，则可传可不传</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>它还可以作为表达式（Expression）来使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> message = <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="string">&quot;Big&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Small&quot;</span></span><br><span class="line"></span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Big</span><br></pre></td></tr></table></figure><p>我们会经常遇到可空的变量，并且要判断它们是否为空。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (text != <span class="literal">null</span>) text.length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 针对这种情况就提供了一种简写，叫做 <strong>Elvis 表达式。</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> text?.length ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>大于两个逻辑分支的情况下，我们使用 when</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span>(i) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;一&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;二&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;i 不是一也不是二&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">一</span><br></pre></td></tr></table></figure><p>它同时也可以作为表达式，为变量赋值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> message = <span class="keyword">when</span>(i) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">&quot;一&quot;</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">&quot;二&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;i 不是一也不是二&quot;</span> <span class="comment">// 如果去掉这行，会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p><strong>when 表达式要求它里面的逻辑分支必须是完整的</strong>，如果去掉 else 分支，编译器将报错</p><h1 id="循环迭代：while-与-for"><a href="#循环迭代：while-与-for" class="headerlink" title="循环迭代：while 与 for"></a>循环迭代：while 与 for</h1><p>Kotlin 的 for 语句更多的是用于“迭代”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了迭代数组和集合以外，Kotlin 还支持迭代一个“区间”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneToThree = <span class="number">1.</span><span class="number">.3</span> <span class="comment">// 代表 [1, 3]</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> oneToThree) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>还可以<strong>逆序迭代</strong>一个区间</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>从 6 到 0，每次迭代的步长是 2，这意味着 6 迭代过后，到 4、2，最后到 0。<br><strong>需要特别注意的是</strong>，逆序区间我们不能使用“6..0”来定义，如果用这样的方式来定义的话，代码将无法正常运行。</p><h1 id="Kotlin优化点"><a href="#Kotlin优化点" class="headerlink" title="Kotlin优化点"></a>Kotlin优化点</h1><ul><li>支持类型推导；</li><li>代码末尾不需要分号；</li><li>字符串模板；</li><li>原始字符串，支持复杂文本格式；</li><li>单一表达式函数，简洁且符合直觉；</li><li>函数参数支持默认值，替代 Builder 模式的同时，可读性还很强；</li><li>if 和 when 可以作为表达式。</li></ul><p>同时，JetBrains 也非常清楚开发者在什么情况下容易出错，所以，它在语言层面也做了很多改进：</p><ul><li>强制区分“可为空变量类型”和“不可为空变量类型”，规避空指针异常；</li><li>推崇不可变性（val），对于没有修改需求的变量，IDE 会智能提示开发者将“var”改为“val”；</li><li>基础类型不支持隐式类型转换，这能避免很多隐藏的问题；</li><li>数组访问行为与集合统一，不会出现 array.length、list.size 这种恼人的情况；</li><li>函数调用支持命名参数，提高可读性，在后续维护代码的时候不易出错；</li><li>when 表达式，强制要求逻辑分支完整，让你写出来的逻辑永远不会有漏洞。</li></ul><h1 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h1><blockquote><ul><li><strong>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></strong></li><li><strong>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></strong></li><li><strong>Github：<a href="https://github.com/droidYu">droidYu</a></strong></li><li><strong>个人博客：<a href="https://droidyu.github.io/">droidYu</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemServer 进程启动过程</title>
      <link href="/android/framework/system-server/"/>
      <url>/android/framework/system-server/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/framework/system-launch/">《浅析Android系统启动过程》</a>简要讲解了Android系统整体启动过程，今天我们看一下其中一个重要的过程：<code>SystemServer</code>进程是如何启动的。</p><blockquote><p><strong>文中源码基于<a href="https://github.com/aosp-mirror/platform_frameworks_base/tree/oreo-release"><code>Android 8.0</code></a></strong></p></blockquote><p>上篇文章<a href="https://droidyu.github.io/android/framework/zygote/">《Zygote进程启动过程》</a>提到<code>Zygote</code>启动过程中调用了<code>startSystemServer</code>启动<code>SystemServer</code>进程，我们继续跟进里面的代码看<code>SystemServer</code>进程是如何启动的。</p><p>在<code>startSystemServer</code>中通过<code>fork</code>方式创建了<code>SystemServer</code>进程，并调用<code>handleSystemServerProcess</code>处理<code>SystemServer</code>进程，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ClassLoader cl = <span class="keyword">null</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);<span class="comment">//---1---</span></span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);---<span class="number">2</span>---</span><br></pre></td></tr></table></figure><p>注释1创建了<code>ClassLoader</code>，用于加载类。注释2调用了<code>ZygoteInit.zygoteInit</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="params"><span class="function">            ClassLoader classLoader)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, <span class="string">&quot;RuntimeInit: Starting application from zygote&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        ZygoteInit.nativeZygoteInit();<span class="comment">//---1---</span></span><br><span class="line">        RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);<span class="comment">//---2---</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处通过<code>native</code>方法，创建了<code>Binder</code>线程池，用于跨进程通信。注释2处调用<code>RuntimeInit.applicationInit</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Arguments args;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            Slog.e(TAG, ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        invokeStaticMain(args.startClass, args.startArgs, classLoader);<span class="comment">//---1---</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看注释1处<code>invokeStaticMain</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);<span class="comment">//---1---</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);---<span class="number">2</span>---</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Zygote.MethodAndArgsCaller(m, argv);---<span class="number">3</span>---</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处通过反射获取传入的<code>className</code>类，从最开始的<code>startSystemServer</code>方法可以知道，这里的<code>className</code>就是<code>args</code>参数中的<code>com.android.server.SystemServer</code>，所以反射得到的类是<code>SystemServer</code>类。注释2处通过反射得到<code>SystemServer</code>的<code>main</code>方法。注释3处将<code>Method</code>和<code>argv</code>作为参数，创建了<code>Zygote.MethodAndArgsCaller</code>并抛出，那抛出的这个<code>Zygote.MethodAndArgsCaller</code>是在哪里<code>catch</code>的？顺着源码返回去看可以知道这个<code>Zygote.MethodAndArgsCaller</code>是在启动<code>Zygote</code>进程时<code>main</code>方法里捕获的，这里只贴了关键代码，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZygoteInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        <span class="keyword">catch</span> (Zygote.MethodAndArgsCaller caller) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>catch</code>里执行了<code>caller.run()</code>方法，我们再看<code>Zygote.MethodAndArgsCaller</code>的<code>run</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);<span class="comment">//---1---</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里只调用了<code>mMethod.invoke</code>，回到之前的代码，其实就是用反射的方式调用了<code>SystemServer</code>的<code>main</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看<code>SystemServer</code>的<code>run</code>方法，由于代码很长，这里只贴关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);<span class="comment">//2</span></span><br><span class="line">    createSystemContext();<span class="comment">//3</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);<span class="comment">//4</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<span class="comment">//5</span></span><br><span class="line">     </span><br><span class="line">    startBootstrapServices();<span class="comment">//6</span></span><br><span class="line">    startCoreServices();<span class="comment">//7</span></span><br><span class="line">    startOtherServices();<span class="comment">//8</span></span><br><span class="line">    </span><br><span class="line">    Looper.loop();<span class="comment">//9</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>注释1处初始化<code>Looper</code>；注释2加载了<code>android_servers.so</code>库；注释3创建系统<code>Context</code>；注释4创建<code>SystemServiceManager</code>；注释5将<code>SystemServiceManager</code>添加到本地服务；注释6启动引导服务；注释7启动核心服务；注释8启动其他服务；注释9开启Looper循环。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android系统启动 </tag>
            
            <tag> Android Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zygote进程启动过程</title>
      <link href="/android/framework/zygote/"/>
      <url>/android/framework/zygote/</url>
      
        <content type="html"><![CDATA[<p>上篇文章<a href="https://droidyu.github.io/android/framework/system-launch/">《浅析Android系统启动过程》</a>简要讲解了Android系统整体启动过程，今天我们看一下其中一个重要的过程：<code>Zygote</code>进程是如何启动的。</p><blockquote><p><strong>文中源码基于<a href="https://github.com/aosp-mirror/platform_frameworks_base/tree/oreo-release"><code>Android 8.0</code></a></strong></p></blockquote><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><code>Zygote</code>进程是通过<code>init</code>进程启动起来的，我们直接看<code>Zygote</code>进程的入口函数，位于<code>ZygoteInit</code>类中的<code>main</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZygoteInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">        <span class="comment">//创建Socket</span></span><br><span class="line">        zygoteServer.registerServerSocket(socketName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载类和资源</span></span><br><span class="line">        preload(bootTimingsTraceLog);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动SystemServer进程</span></span><br><span class="line">        startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进入循环等待请求</span></span><br><span class="line">        zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></table></figure><p>由上面代码可以看出<code>Zygote</code>进程主要做了4件事：</p><ol><li>创建一个<code>Socket</code>用于跨进程通信</li><li>预加载类和资源</li><li>启动<code>SystemServer</code>进程</li><li>进入循环等待<code>AMS</code>请求创建新的应用程序进程</li></ol><p>我们继续跟进看看各个方法具体做了什么，</p><h1 id="registerServerSocket"><a href="#registerServerSocket" class="headerlink" title="registerServerSocket"></a>registerServerSocket</h1><p>创建<code>socket</code>用于跨进程通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerServerSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> fileDesc;</span><br><span class="line">            <span class="comment">//拼接socket名称</span></span><br><span class="line">            <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取socket环境变量</span></span><br><span class="line">                String env = System.getenv(fullSocketName);</span><br><span class="line">                <span class="comment">//将socket环境变量转换为fd文件描述符的参数</span></span><br><span class="line">                fileDesc = Integer.parseInt(env);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">&quot; unset or invalid&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建fd文件描述符</span></span><br><span class="line">                FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">                <span class="comment">//设置fd参数</span></span><br><span class="line">                fd.setInt$(fileDesc);</span><br><span class="line">                <span class="comment">//传入fd创建Socket</span></span><br><span class="line">                mServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">&quot;Error binding to local socket &#x27;&quot;</span> + fileDesc + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h1><p>预加载各种类及资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(BootTimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载/system/etc/preloaded-classes目录下常用的类</span></span><br><span class="line">        preloadClasses();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载drawables、color、freeform_multi_window_drawables等常用资源</span></span><br><span class="line">        preloadResources();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载OpenGL</span></span><br><span class="line">        preloadOpenGL();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载android、compiler_rt、jnigraphics库</span></span><br><span class="line">        preloadSharedLibraries();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//预加载字体资源</span></span><br><span class="line">        preloadTextResources();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="startSystemServer"><a href="#startSystemServer" class="headerlink" title="startSystemServer"></a>startSystemServer</h1><p>启动<code>SystemServer</code>进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName, ZygoteServer zygoteServer)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">            OsConstants.CAP_IPC_LOCK,</span><br><span class="line">            OsConstants.CAP_KILL,</span><br><span class="line">            OsConstants.CAP_NET_ADMIN,</span><br><span class="line">            OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">            OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">            OsConstants.CAP_NET_RAW,</span><br><span class="line">            OsConstants.CAP_SYS_MODULE,</span><br><span class="line">            OsConstants.CAP_SYS_NICE,</span><br><span class="line">            OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">            OsConstants.CAP_SYS_TIME,</span><br><span class="line">            OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">            OsConstants.CAP_WAKE_ALARM</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/* Containers run without this capability, so avoid setting it in that case */</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        String args[] = &#123;</span><br><span class="line">            <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1032,3001,3002,3003,3006,3007,3009,3010&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">            <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">        &#125;;<span class="comment">//---1---</span></span><br><span class="line">        ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.debugFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);<span class="comment">//---2---</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            handleSystemServerProcess(parsedArgs);<span class="comment">//---3---</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处创建<code>args</code>数组，用来保存用于启动<code>SystemServer</code>进程的启动参数。注释2处调用<code>Zygote.forkSystemServer</code>方法，通过<code>fork</code>当前进程来创建<code>SystemServer</code>进程，如果进程的<code>pid</code>值为<code>0</code>，则表示当前运行在新创建的进程中，就会执行注释3处的<code>handleSystemServerProcess</code>来处理<code>SystemServer</code>进程。关于<code>SystemServer</code>进程的启动放在之后的文章讲解。</p><h1 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h1><p>死循环等待<code>AMS</code>请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---1---</span></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;<span class="comment">//---2---</span></span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">//---3---</span></span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);<span class="comment">//---4---</span></span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> done = peers.get(i).runOnce(<span class="keyword">this</span>);<span class="comment">//---5---</span></span><br><span class="line">                    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                        peers.remove(i);</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处获取之前创建的<code>socket</code>的<code>fd</code>添加到<code>fds</code>中，然后进入无限循环来等待<code>AMS</code>请求<code>Zygote</code>进程创建新的应用程序进程。注释2处遍历<code>fds</code>存储的信息放到<code>pollFds</code>中。注释3处对<code>pollFds</code>进行遍历，如果<code>i=0</code>说明<code>pollFds</code>中没有内容，此时会通过注释4处<code>acceptCommandPeer</code>方法创建一个<code>ZygoteConnection</code>，然后获取<code>ZygoteConnection</code>的<code>fd</code>并加入到<code>fds</code>中，以便接收下次<code>AMS</code>的请求。而当<code>i！=0</code>时，会执行注释5处的<code>peers.get(i).runOnce(this)</code>，这个方法用来处理<code>AMS</code>发送过来的请求，处理完后，将<code>ZygoteConnection</code>从<code>peers</code>中移除，将<code>fd</code>从<code>fds</code>中移除，并进入下次循环。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android系统启动 </tag>
            
            <tag> Android Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（三）工厂方法模式</title>
      <link href="/DesignPattern/factory-method/"/>
      <url>/DesignPattern/factory-method/</url>
      
        <content type="html"><![CDATA[<p>简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。上篇文章<a href="https://droidyu.github.io/DesignPattern/simple-factory/">《设计模式（二）简单工厂模式》</a>讲了简单工厂模式，我们今天就来看一下工厂方法模式。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的结构图如下所示：</p><p><img src="https://pic.imgdb.cn/item/621998f92ab3f51d916520a6.jpg"></p><ul><li><code>AbstractFactory</code>：抽象工厂类，提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li><code>Factory</code>：工厂类，负责实现创建所有实例的内部逻辑。创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li><code>AbstractProduct</code>：抽象产品类，这是简单工厂模式所创建的所有对象的父类。</li><li><code>Product</code>：具体产品类，继承自抽象产品类。</li></ul><p>下面用代码来实现一下：</p><ol><li>创建抽象产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建具体产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OPPO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;VIVO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建抽象工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>具体工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OppoPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VivoPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>调用工厂创建产品</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone oppoPhone = <span class="keyword">new</span> OppoFactory().createPhone();</span><br><span class="line">        oppoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone vivoPhone = <span class="keyword">new</span> VivoFactory().createPhone();</span><br><span class="line">        vivoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone xiaomiPhone = <span class="keyword">new</span> XiaomiFactory().createPhone();</span><br><span class="line">        xiaomiPhone.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6219bdbe2ab3f51d91b54a7f.jpg"></p><p>打印日志可以看到这种品牌的手机都启动了。至此，我们就完成了工厂方法模式的创建。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于每个具体产品对应一个具体工厂，所以会产生很多类，而且每次创建产品都需要<code>new</code>一个工厂出来，对系统的性能有一定的影响。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>为了更好的管理工厂类，而且让工厂类可重用，我们可以创建一个工厂的工厂，使用<code>HashMap</code>来对工厂进行缓存，在使用工厂时直接从<code>HashMap</code>获取缓存的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactoryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">        oppo, vivo, xiaomi</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;PhoneType, PhoneFactory&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(PhoneType.oppo, <span class="keyword">new</span> OppoFactory());</span><br><span class="line">        map.put(PhoneType.vivo, <span class="keyword">new</span> VivoFactory());</span><br><span class="line">        map.put(PhoneType.xiaomi, <span class="keyword">new</span> XiaomiFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneFactory <span class="title">getFactory</span><span class="params">(PhoneType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone oppoPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.oppo).createPhone();</span><br><span class="line">        oppoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone vivoPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.vivo).createPhone();</span><br><span class="line">        vivoPhone.start();</span><br><span class="line"></span><br><span class="line">        Phone xiaomiPhone = PhoneFactoryFactory.getFactory(PhoneFactoryFactory.PhoneType.xiaomi).createPhone();</span><br><span class="line">        xiaomiPhone.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li></ul><p>缺点：</p><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li></ul><p><strong>示例代码已上传至<a href="https://github.com/droidYu/DesignPattern/blob/main/app/src/main/java/com/droidyu/designpattern/factory/method/FactoryMethod.java">Github</a></strong></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式（二）简单工厂模式</title>
      <link href="/DesignPattern/simple-factory/"/>
      <url>/DesignPattern/simple-factory/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p><p>简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。我们今天就来看一下简单工厂模式。</p><h1 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h1><p>定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>简而言之就是在使用一个具体对象的时候，我们不直接<code>new</code>一个对象，而是通过一个单独的工厂类来<code>new</code>这个对象。</p><p>简单工厂模式的结构图如下所示：</p><p><img src="https://pic.imgdb.cn/item/621324532ab3f51d91458fcf.jpg"></p><ul><li><code>Factory</code>：工厂类，负责实现创建所有实例的内部逻辑。创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li><code>AbstractProduct</code>：抽象产品类，这是简单工厂模式所创建的所有对象的父类。</li><li><code>Product</code>：具体产品类，继承自抽象产品类。</li></ul><p>我们以生产手机为例，用代码来实现一下：</p><p>（1）<strong>抽象产品类</strong></p><p>创建一个手机的抽象产品类，其有一个抽象方法用于启动手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>具体产品类</strong></p><p>我们创建各种品牌的手机，他们都继承自父类<code>Phone</code>，并实现了启动的方法。具体分为oppo手机，vivo手机和小米手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OppoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OPPO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VivoPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;VIVO start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）<strong>工厂类</strong></p><p>我们创建一个手机工厂，用来生产各种手机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">createPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;oppo&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> OppoPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;vivo&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> VivoPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;xiaomi&quot;</span>:</span><br><span class="line">                phone = <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）<strong>调用工厂类生产手机并启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;oppo&quot;</span>).start();</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;vivo&quot;</span>).start();</span><br><span class="line">    PhoneFactory.createPhone(<span class="string">&quot;xiaomi&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"></p><p>打印日志可以看到这种品牌的手机都启动了。至此，我们就完成了简单工厂模式的创建。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>简单工厂模式的问题在于如果后续有其他品牌的手机需要生产，那我们就要修改工厂的<code>if-else</code>语句，如果逻辑简单还好，但在实际开发中，<code>if-else</code>的代码块逻辑可能很复杂，稍有疏忽就容易制造出成吨的<code>bug</code>。那如何解决这样的问题呢？我们可以利用泛型和反射来优化我们的简单工厂。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>对于普通的简单工厂，需要维护好传入的生产需求和具体生产的对象的关系，根据需求生产具体产品。有没有什么一劳永逸的方法呢？当然有，我们可以创建一个万能的自动化工厂，传入什么类型的产品，工厂就生产什么样的产品。工厂内部的逻辑不需要根据传入的产品变更而更改。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Phone&gt; <span class="function">T <span class="title">createPhone</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            phone = (Phone) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AutoPhoneFactory.createPhone(OppoPhone.class).start();</span><br><span class="line">    AutoPhoneFactory.createPhone(VivoPhone.class).start();</span><br><span class="line">    AutoPhoneFactory.createPhone(XiaomiPhone.class).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6210d9f22ab3f51d919d3512.jpg"><br>从日志可以看到各种品牌的手机同样是启动了，而且对于新增的品牌，我们无需修改工厂类，只需传入新增品牌的<code>.class</code>就可以创建对应的实例对象了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>使用场景</strong>：</p><ul><li>工厂类负责创建的对象较少；</li><li>客户只需要知道传入工厂类的参数，而无需关心创建对象的逻辑。</li></ul><p><strong>优点</strong>：</p><ul><li>使用户根据参数获得对应的类实例，避免直接实例化类，降低了耦合性。</li></ul><p><strong>缺点</strong>：</p><ul><li>可实例化的类型在编译期间已经被确定。如果增加新类型，需要修改工厂，违背了开放封闭原则；</li><li>使用简单工厂需要知道所要生成的类型，当子类过多或子类层次过多时不适合使用简单工厂模式；</li><li>对于使用泛型和反射优化的简单工厂类，因为使用了泛型创建实例，其性能有一定的问题，所以虽然做到了新增产品类不用修改工厂，但是在大量创建实例时，性能有一定损耗。</li></ul><p><strong>示例代码已上传<a href="https://github.com/droidYu/DesignPattern/blob/main/app/src/main/java/com/droidyu/designpattern/factory/simple/SimpleFactory.java">Github</a></strong></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级特性（二）注解处理 之 3分钟写半个Retrofit框架</title>
      <link href="/Java/annotation-processor-1/"/>
      <url>/Java/annotation-processor-1/</url>
      
        <content type="html"><![CDATA[<p>上篇文章<a href="https://droidyu.github.io/Java/annotation/">《Java高级特性（一）注解的分类及使用》</a>讲了注解相关的基础知识，但是基本的注解声明和使用，并不能发挥注解的真正效果。如果要让注解产生实际的作用，就需要搭配注解处理器来使用。至于为什么说写半个<code>Retrofit</code>框架，因为本文只涉及到<code>Retrofit</code>框架中关于注解处理的内容（大佬轻喷）。</p><p>我们先回顾一下<code>Retrofit</code>是怎么用的？（代码摘自<a href="https://square.github.io/retrofit/"><code>Retrofit</code>官网</a>）</p><p>第一步：定义一个接口，接口里面定义方法，使用<code>@GET、@POST</code>等注解标注我们定义的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path(&quot;user&quot;)</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：创建<code>retrofit</code>实例，然后调用<code>retrofit.create()</code>方法，将我们定义的接口<code>.class</code>传入<code>create</code>方法。通过<code>create</code>方法生成实现了我们定义的接口的代理对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><p>第三步：调用实现了接口的代理对象的具体方法，完成网络请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br></pre></td></tr></table></figure><p>那<code>Retrofit</code>是如何将<code>@GET</code>注解里的接口地址解析出来并使用的呢？这里就用到了注解处理，使用反射的方式获取了方法的注解传入的参数值。下面我们就自己用代码来实现一下。</p><ol><li>定义一个<code>@GET</code>注解和<code>@POST</code>注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> POST &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义<code>Api</code>抽象类，类比<code>Retrofit</code>的第一步：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(&quot;https://api.github.com&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getGithub</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;https://api.github.com/droidYu&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Retrofit</code>涉及到动态代理到知识，这里不进行深入讲解，所以我们使用了抽象类来代替<code>Retrofit</code>的接口。</p><ol start="3"><li>在<code>main</code>方法中调用<code>getAnnotation()</code>方法，并传入<code>Api.class</code>，这一步可以类比<code>Retrofit</code>框架中第二步<code>retrofit.create(GitHubService.class)</code>方法的调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getAnnotation(Api.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>getAnnotation</code>方法中通过反射到方式获取<code>@GET</code>和<code>@POST</code>注解里的请求地址并打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAnnotation</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取传入的.class中的所有方法</span></span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">//遍历获取到到方法数组，获取每个方法中的所有注解</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">//遍历获取到的所有注解，判断注解类型，分别打印注解内容</span></span><br><span class="line">            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">                print(<span class="string">&quot;GET&quot;</span>,method,((GET) annotation).value());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">                print(<span class="string">&quot;POST&quot;</span>,method,((POST) annotation).value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>print</code>方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String methodType,Method method, String annotationValue)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;从 &quot;</span>+methodType+<span class="string">&quot; 方法：&quot;</span>+method.getName()+<span class="string">&quot; 获取到注解的值：&quot;</span> + annotationValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：<br><img src="https://pic.imgdb.cn/item/620f86a52ab3f51d910992b3.jpg"></p><p>从打印的内容中，我们可以看到，我们已经成功的从我们自己定义的注解中获取到了请求地址。这其实就是<code>Retrofit</code>框架用注解获取请求地址的的核心设计思路，只不过<code>Retrofit</code>框架的这部分代码更加完善，使得框架非常的简单易用。至此，我们花3分钟的时间，就写了半个<code>Retrofit</code>框架，即<code>Retrofit</code>注解处理的核心代码。</p><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/tree/main/app/src/main/java/com/droidyu/javademo/annotation/processor">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级特性（一）注解的分类及使用</title>
      <link href="/Java/annotation/"/>
      <url>/Java/annotation/</url>
      
        <content type="html"><![CDATA[<h1 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h1><p>注解分为标准注解和元注解</p><h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>标准注解有以下几种：</p><ul><li><code>@Override</code>：对覆盖超类中的方法进行标注，如果被标注的方法并没有实际覆盖超类中的方法，编译器会发错错误警告。</li><li><code>@Deprecated</code>：对不鼓励使用或已过时的方法进行标注，当开发人员对这些被标注的方法进行调用时，会显示该方法已过时的提示信息。</li><li><code>@SuppressWarnings</code>：选择性的取消特定代码段中的警告。</li><li><code>@SafeVarargs</code>：JDK 7 新增的注解，用来声明使用了可变长度参数的方法，其在与泛型类一起使用时会出现类型安全问题。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是用来标注注解的注解，在注解定义时使用。有以下几种：</p><ul><li><code>@Targe</code>：标注所修饰的对象范围。</li><li><code>@Inherited</code>：表示注解可以被继承。</li><li><code>@Documented</code>：表示注解应该被JavaDoc工具记录。</li><li><code>@Retention</code>：用来声明注解的保留策略。</li><li><code>@Repeatable</code>：JDK 8 新增的注解，允许一个注解在同一声明类型（类、属性或方法）中多次使用。</li></ul><p>下面重点介绍下<code>@Targe</code>注解及<code>@Retention</code>注解：</p><h3 id="Targe注解"><a href="#Targe注解" class="headerlink" title="@Targe注解"></a><code>@Targe</code>注解</h3><p>其中<code>@Targe</code>注解的取值是一个<code>ElementType</code>类型的数值。这里有以下几种取值，对应不用的对象范围。</p><ul><li><code>ElementType.TYPE</code>：声明类、接口或枚举类型。</li><li><code>ElementType.FIELD</code>：声明成员变量。</li><li><code>ElementType.METHOD</code>：声明方法。</li><li><code>ElementType.PARAMETER</code>：声明参数。</li><li><code>ElementType.CONSTRUCTOR</code>：声明构造方法。</li><li><code>ElementType.LOCAL_VARIABLE</code>：声明局部变量。</li><li><code>ElementType.ANNOTATION_TYPE</code>：声明注解类型。</li><li><code>ElementType.PACKAGE</code>：声明包。</li><li><code>ElementType.TYPE_PARAMETER</code>：声明参数类型。</li><li><code>ElementType.TYPE_USE</code>：使用类型。</li><li><code>ElementType.MODULE</code>：声明模块。</li></ul><h3 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a><code>@Retention</code>注解</h3><p><code>@Retention</code>注解有3种类型，分别表示不同级别的保留策略。</p><ul><li><code>RetentionPolicy.SOURCE</code>：源码级注解。注解信息只保留在<code>.java</code>源码中。源码在编译后，注解信息被丢弃，不会保留在<code>.class</code>中。</li><li><code>RetentionPolicy.CLASS</code>：编译时注解。注解信息会保留在<code>.java</code>源码以及<code>.class</code>中。当运行Java程序时，JVM会丢弃该注解信息，不会保留在JVM中。</li><li><code>RetentionPolicy.RUNTIME</code>：运行时注解。当运行Java程序时，JVM也会保留该注解信息，可以通过反射获取该注解信息。</li></ul><h1 id="注解的定义和使用"><a href="#注解的定义和使用" class="headerlink" title="注解的定义和使用"></a>注解的定义和使用</h1><h2 id="基本定义和使用"><a href="#基本定义和使用" class="headerlink" title="基本定义和使用"></a>基本定义和使用</h2><p>定义新的注解类型使用<code>@interface</code>关键字，这与定义一个接口很像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义完成后，就可以在程序中使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解成员变量的定义和使用"><a href="#注解成员变量的定义和使用" class="headerlink" title="注解成员变量的定义和使用"></a>注解成员变量的定义和使用</h2><p>注解只有成员变量，没有方法。注解的成员变量在注解定义中以“无参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了<code>name</code>和<code>age</code>两个成员变量，使用该注解时就要给两个成员变量指定值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(name = &quot;droidYu&quot;,age = 0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在定义成员变量时，用<code>default</code>关键字为其指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;droidYu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span>  0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时就可以不进行赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义成员变量时，有个一特殊的成员变量<code>value</code>，在使用时可以不用写 <code>value = </code>，而直接传入<code>value</code>的值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;droidYu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span>  0</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;no value&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>value=</code>可以省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;no value&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用元注解定义注解"><a href="#使用元注解定义注解" class="headerlink" title="使用元注解定义注解"></a>使用元注解定义注解</h2><p>定义注解时，还可以为注解添加元注解，例如使用<code>@Target</code>和<code>@Retention</code>元注解来定义只能用来注解方法的运行时注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethod &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>MyMethod</code>注解就只能标注在方法上，如果标注在类上，编译器就会提示错误警告，编译不能通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;no value&quot;)</span></span><br><span class="line"><span class="meta">@MyMethod</span> <span class="comment">//这里会报错，编译不能通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyMethod</span> <span class="comment">//正确的使用位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/tree/main/app/src/main/java/com/droidyu/javademo/annotation">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（二）Java内存模型</title>
      <link href="/Java/thread/volatile/"/>
      <url>/Java/thread/volatile/</url>
      
        <content type="html"><![CDATA[<p>Java 内存模型（JMM）是一种抽象的概念，并不真实存在，它描述了一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。JVM中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此它存在可见性问题。Java内存模型定义了线程和主存间的抽象关系：线程之间的共享变量存储在主存中，每个线程有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。需要注意的是本地内存是Java内存模型的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java内存模型的抽象示意图如下所示：</p><p><img src="https://pic.imgdb.cn/item/620e47ab2ab3f51d9164947f.jpg"></p><p>线程A与线程B要通信的话，要经历下面两个步骤：</p><ol><li>线程A把线程A本地内存中更新过的内存共享变量刷新到主存；</li><li>线程B到主存中取线程A之前更新过的共享变量。</li></ol><p>所以我们在执行下面语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>语句所在的线程会对变量i所在的缓存进行赋值操作，然后再写入主存中，而不是直接将数值0写入主存。</p><p>为了有个直观的感受，我们用一段代码来实现一下。先定义一个类<code>VolatileDemo</code>，包含一个<code>running</code>字段和一个<code>stop</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileDemo demo = <span class="keyword">new</span> VolatileDemo();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (demo.running) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.stop();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>方法，即主线程中创建<code>VolatileDemo</code>对象实例，然后新创建一个子线程，进入<code>while</code>循环不断的判断<code>running</code>属性。我们让主线程<code>sleep</code>1000毫秒，然后执行<code>stop</code>更新<code>running</code>的值为<code>false</code>，按正常逻辑如果<code>running = false</code>的话，子线程就会执行完，打印<code>end</code>，然后整个程序执行完毕。我们运行程序看一下：<br><img src="https://pic.imgdb.cn/item/620e514f2ab3f51d9172c4a6.jpg"></p><p>发现子线程并没有打印<code>end</code>，并且程序一直在运行，没有结束退出。说明主线程更新的<code>running = false</code>，子线程并不知道。</p><p>示例代码已上传<a href="https://github.com/droidYu/JavaDemo/blob/main/app/src/main/java/com/droidyu/javademo/thread/volatile_demo/VolatileDemo.java">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）线程状态及线程创建方式</title>
      <link href="/Java/thread/status-and-create/"/>
      <url>/Java/thread/status-and-create/</url>
      
        <content type="html"><![CDATA[<p>Java多线程编程作为每一个Android Coder都必须掌握的技术，今天我们就来聊一聊关于Java多线程的点点滴滴。Android沿用了Java的线程模型，一个Android应用创建时会开启一个线程，这个线程就是我们熟知的主线程，也叫UI线程。如果我们在主线程直接进行网络请求，系统会直接报错，提示不能在主线程请求网络，至于问什么，是因为网络访问是一个耗时的操作，如果网络访问很慢，就会导致ANR（Application Not Response），从Android3.0开始，系统就要求网络访问必须在子线程中进行，否则就会抛出异常。</p><p>关于线程和进程的描述以及二者的关系，网络上一搜一大把，这里就不再赘述，我们主要来看一下线程的各种状态。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><ul><li><strong>New</strong>：新创建状态。线程被创建，还没调用<code>start</code>方法。</li><li><strong>Runnable</strong>：可运行状态。一旦调用了<code>start</code>方法，线程就处于Runnable状态。</li><li><strong>Blocked</strong>：阻塞状态。线程被锁阻塞。</li><li><strong>Waiting</strong>：等待状态。线程暂时不活动，也不运行任何代码，直到线程调度器重新激活它。</li><li><strong>Timed waiting</strong>：超时等待状态。和等待状态不同的是，它可以在指定的时间自行返回。</li><li><strong>Terminated</strong>：终止状态。表示当前线程已经执行完毕。有两种情况可以进入终止状态：一是<code>run</code>方法执行完毕正常退出，二是因为没有捕获的异常而终止了<code>run</code>方法，导致线程终止。<br>各种状态的关系以及流转如下图所示：<br><img src="https://pic.imgdb.cn/item/620c9caa2ab3f51d91e1189e.jpg"></li></ul><h1 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h1><p>线程的创建一般有3种方式，其中前两种最常用，但在日常开发中建议尽量不要自己手动创建线程，因为自己创建的线程难以管理，且如果线程很多的话性能会受到一定的影响。推荐使用<code>Executor</code>相关的线程池框架管理线程。</p><p>需要注意的是调用<code>start</code>方法后并不是立即执行线程中的代码，而是使线程进入可运行状态，至于什么时候运行是由操作系统决定的。</p><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyRunnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello MyCallable&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;String&gt; future = service.submit(myCallable);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，程序通过3种方式创建了线程，并打印了运行结果：<br><img src="https://pic.imgdb.cn/item/620cadbf2ab3f51d9105d8e1.jpg"></p><p>源码已上传到<a href="https://github.com/droidYu/JavaDemo/blob/main/app/src/main/java/com/droidyu/javademo/thread/create/ThreadCreate.java">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（十一）View的draw流程</title>
      <link href="/android/view/11-view-draw/"/>
      <url>/android/view/11-view-draw/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>提到<code>View</code>的工作流程包括了<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，今天我们就来看一下<code>View</code>的<code>draw</code>流程是怎样的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p><code>View</code>的<code>draw</code>流程很简单，源码里的注释官方也写的很清楚，我们看<code>View</code>的<code>draw</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 2, save the canvas&#x27; layers</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    onDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">    drawDefaultFocusHighlight(canvas);</span><br></pre></td></tr></table></figure><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>官方注释已经清楚的写了每一步的工作：</p><ol><li>如果需要，则绘制背景（<code>drawBackground</code>）</li><li>保存当前canvas层</li><li>绘制View的内容（<code>onDraw</code>）</li><li>绘制子View（<code>dispatchDraw</code>）</li><li>如果需要，则绘制View的褪色边缘，类似于阴影效果</li><li>绘制装饰，比如滚动条（<code>onDrawForeground</code>）</li><li>绘制默认焦点高亮效果（<code>drawDefaultFocusHighlight</code>）</li></ol><blockquote><p><strong>注释中说明了第2步和第5步可以跳过，这里就不展开讲解，在此重点分析其他步骤。</strong></p></blockquote><h1 id="步骤1：绘制背景"><a href="#步骤1：绘制背景" class="headerlink" title="步骤1：绘制背景"></a>步骤1：绘制背景</h1><p>进入<code>View</code>的<code>drawBackground</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    ...</span><br><span class="line">    setBackgroundBounds();  <span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    background.draw(canvas);    <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注释1处设置背景范围，注释2处通过<code>Drawable</code>的<code>draw</code>方法来绘制背景，关于<code>Drawable</code>将在后面的文章详细讲解。看注释1的<code>setBackgroundBounds</code>是如何设置背景范围的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackgroundBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackgroundSizeChanged &amp;&amp; mBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackground.setBounds(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);    <span class="comment">//1</span></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">        rebuildOutline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到注释1处通过<code>View</code>的<code>mRight、mLeft、mBottom、mTop</code>等参数调用<code>mBackground.setBounds</code>方法来进行绘制范围的设置。</p><h1 id="步骤2：保存当前canvas层"><a href="#步骤2：保存当前canvas层" class="headerlink" title="步骤2：保存当前canvas层"></a>步骤2：保存当前canvas层</h1><h1 id="步骤3：绘制View的内容"><a href="#步骤3：绘制View的内容" class="headerlink" title="步骤3：绘制View的内容"></a>步骤3：绘制View的内容</h1><p>步骤3调用了<code>View</code>的<code>onDraw</code>方法，这个方法是一个空实现，因为不同的<code>View</code>有不同的内容，所以需要我们自己去实现，即在自定义<code>View</code>时重写该方法来实现我们自己的绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="步骤4：绘制子View"><a href="#步骤4：绘制子View" class="headerlink" title="步骤4：绘制子View"></a>步骤4：绘制子View</h1><p>步骤4调用了<code>dispatchDraw</code>方法，这个方法也是个空实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewGroup</code>重写了这个方法，我们看<code>ViewGroup</code>的<code>dispatchDraw</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        more |= drawChild(canvas, transientChild, drawingTime);</span><br></pre></td></tr></table></figure><p>源码很长，这里只贴出关键代码，在<code>dispatchDraw</code>方法中遍历子<code>View</code>并调用<code>drawChild</code>方法，我们继续看<code>drawChild</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>drawChild</code>方法实际就是调用了子<code>View</code>的<code>draw</code>方法对子<code>View</code>进行绘制</p><h1 id="步骤5：绘制View的阴影效果"><a href="#步骤5：绘制View的阴影效果" class="headerlink" title="步骤5：绘制View的阴影效果"></a>步骤5：绘制View的阴影效果</h1><h1 id="步骤6：绘制装饰"><a href="#步骤6：绘制装饰" class="headerlink" title="步骤6：绘制装饰"></a>步骤6：绘制装饰</h1><p>步骤6调用了<code>onDrawForeground</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawForeground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    onDrawScrollIndicators(canvas);</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Drawable foreground = mForegroundInfo != <span class="keyword">null</span> ? mForegroundInfo.mDrawable : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (foreground != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;</span><br><span class="line">            <span class="keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                selfBounds.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                        getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ld = getLayoutDirection();</span><br><span class="line">            Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                    foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">            foreground.setBounds(overlayBounds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对<code>ScrollBar</code>及其它装饰进行绘制。</p><h1 id="步骤7：绘制默认焦点高亮效果"><a href="#步骤7：绘制默认焦点高亮效果" class="headerlink" title="步骤7：绘制默认焦点高亮效果"></a>步骤7：绘制默认焦点高亮效果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawDefaultFocusHighlight</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFocusHighlight != <span class="keyword">null</span> &amp;&amp; isFocused()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFocusHighlightSizeChanged) &#123;</span><br><span class="line">            mDefaultFocusHighlightSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> l = mScrollX;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> r = l + mRight - mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> t = mScrollY;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> b = t + mBottom - mTop;</span><br><span class="line">            mDefaultFocusHighlight.setBounds(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">        mDefaultFocusHighlight.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（十）从LinearLayout分析View的布局流程</title>
      <link href="/android/view/10-view-layout/"/>
      <url>/android/view/10-view-layout/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>提到<code>View</code>的工作流程包括了<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，上两篇文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>和<a href="https://droidyu.github.io/android/view/9-ViewGroup-measure/">《View体系（九）从LinearLayout分析ViewGroup的测量流程》</a>分别对<code>View</code>和<code>ViewGroup</code>的<code>measure</code>过程做了分析，今天我们就来看一下<code>View</code>的<code>layout</code>过程是怎样的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>先看<code>View</code>的<code>layout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    onLayout(changed, l, t, r, b);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><code>layout</code>方法很长，这里只贴出关键代码。<code>layout</code>的4个参数<code>l、t、r、b</code>分别代表<code>View</code>从左上右下相对父容器的距离。注释1处根据不同情况会调用<code>setOpticalFrame</code>或<code>setFrame</code>方法，而在<code>setOpticalFrame</code>方法内部也会调用到<code>setFrame</code>，所以我们直接看<code>setFrame</code>做了什么，进入<code>setFrame</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Assign a size and position to this view.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            mLeft = left;</span><br><span class="line">            mTop = top;</span><br><span class="line">            mRight = right;</span><br><span class="line">            mBottom = bottom;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从注释（<code>Assign a size and position to this view.</code>）可以看出，这个方法是为<code>View</code>分配了大小和位置。<code>setFrame</code>将传进来的4个参数分别初始化<code>mLeft、mTop、mRight、mBottom</code>这4个值，这样就确定了该<code>View</code>在父容器的位置。</p><p>接着看上段代码注释2处，可以看到<code>layout</code>内部调用了<code>onLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onLayout</code>是一个空方法，这样设计和<code>ViewGroup</code>中没有<code>onMeasure</code>方法类似，确定位置时不同的控件有不同的实现，所以<code>onLayout</code>需要由具体的控件自己来实现如何布局。所以在<code>View</code>和<code>ViewGroup</code>中都没有实现<code>onLayout</code>方法，我们还是以<code>LinearLayout</code>为例来分析<code>onLayout</code>方法，进入<code>LinearLayout</code>的<code>onLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和测量流程一样，这里根据<code>mOrientation</code>进行不同的布局流程，以纵向布局为例，会进入注释1处<code>layoutVertical</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();   <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;   <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                gravity = minorGravity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                            + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                childTop += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            childTop += lp.topMargin;</span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                    childWidth, childHeight);   <span class="comment">//3</span></span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处获取子<code>View</code>的数量，注释2处循环遍历子<code>View</code> 并调用注释3处的<code>setChildFrame</code>方法确定子<code>View</code>的位置，注释4处对<code>childTop</code>不断进行累加，这样子<code>View</code>才会依次按垂直方向一个接一个的排列下去，而不是堆叠在一起，接着看注释3处的<code>setChildFrame</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部调用了子<code>View</code>的<code>layout</code>方法来确定自己的位置，<code>layout</code>方法文章开头已经讲过，这里不再赘述。<br>至此，就完成了<code>LinearLayout</code>的<code>layout</code>过程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（九）从LinearLayout分析ViewGroup的测量流程</title>
      <link href="/android/view/9-ViewGroup-measure/"/>
      <url>/android/view/9-ViewGroup-measure/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>我们深入分析了<code>View</code>的<code>onMeasure</code>方法，我们今天就来看一下<code>ViewGroup</code>的测量流程。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在<code>View</code>做测量时，会调用<code>View</code>的<code>onMeasure</code>方法，但是我们翻看<code>ViewGroup</code>的源码，并没有发现<code>onMeasure</code>方法，难道<code>ViewGroup</code>不用测量？显然不是，我们换一个类来看，<code>LinearLayout</code>继承自<code>ViewGroup</code>，我们从<code>LinearLayout</code>的源码中找到了熟悉的<code>onMeasure</code>方法，我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;<span class="comment">//1</span></span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br></pre></td></tr></table></figure><p>注释1处根据<code>mOrientation</code>判断是横向排列还是纵向排列来进入不同的测量流程，我们以纵向排列为例，看<code>LinearLayout</code>是如何测量其高度的，进入注释2处的<code>measureVertical</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">                measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                        heightMeasureSpec, usedHeight);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();<span class="comment">//4</span></span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    lp.height = <span class="number">0</span>;</span><br><span class="line">                    consumedExcessSpace += childHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>由于<code>measureVertical</code>方法很长，这里只贴出部分关键代码。注释1处获取子<code>View</code>的数量，注释2处遍历子<code>View</code>并根据测量模式进入不同的<code>if-else</code>分支，这里以<code>wrap_content</code>为例（即<code>AT_MOST</code>模式），则进入<code>else</code>分支，注释3处对子<code>View</code>进行测量，注释4处获取测量到的子<code>View</code>的高度，注释5处对子<code>View</code>的测量结果进行累加作为最终<code>LinearLayout</code>的测量高度。我们进入注释3的<code>measureChildBeforeLayout</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureChildBeforeLayout</span><span class="params">(View child, <span class="keyword">int</span> childIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> totalWidth, <span class="keyword">int</span> heightMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> totalHeight)</span> </span>&#123;</span><br><span class="line">    measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">            heightMeasureSpec, totalHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进入<code>measureChildWithMargins</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处调用了<code>child.measure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure><p>而<code>measure</code>又调用了<code>View</code>的<code>onMeasure</code>方法，对于<code>View</code>的<code>onMeasure</code>方法，之前的文章<a href="https://droidyu.github.io/android/view/8-view-measure/">《View体系（八）深入剖析View的onMeasure方法》</a>已经讲过，这里不再赘述。</p><p>至此<code>LinearLayout</code>的测量已经很清楚了，即对于纵向的<code>LinearLayout</code>并指定高度为<code>wrap_content</code>来说，是通过遍历测量子<code>View</code>的高度并累加作为自己的高度。至于为什么<code>ViewGroup</code>没有<code>onMeasure</code>方法，是因为它无法统一究竟要以什么方式来测量，所以它要让它的子类来各自实现测量方法，最终它的子类又重写<code>onMeasure</code>完成对自己的测量。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(一)单例模式</title>
      <link href="/DesignPattern/singleton/"/>
      <url>/DesignPattern/singleton/</url>
      
        <content type="html"><![CDATA[<p>单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式结构图如下：<br><img src="https://pic.imgdb.cn/item/6205cd2e2ab3f51d910e2d98.jpg"></p><p><code>Client</code>为客户端，<code>Singleton</code>为单例类，<code>Client</code>通过调用<code>Singleton.getInstance()</code>方法获取实例对象。</p><p>下面介绍常见的6种单例写法：</p><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>饿汉式的实现方式比较简单。在类加载的时候，<code>instance</code> 静态实例就已经创建并初始化好了，所以，<code>instance</code> 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 <code>instance</code> 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p><h1 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h1><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现单例是线程不安全的，因为在多线程的时候可能会重复创建单例，导致实例全局不唯一。一般使用下面的方式，即使用<code>synchronized</code>关键字来保证线程安全。</p><h1 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 <code>getInstance()</code> 这个方法加了一把大锁（<code>synchronzed</code>），导致这个函数的并发度很低。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h1 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h1><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法在<code>getSingleton</code>方法中对<code>singleton</code>进行了两次判空，第一次是为了不必要的同步，第二次是在<code>singleton</code>等于<code>null</code>的情况下才创建实例。<br>在这里使用<code>volatile</code>会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 <code>DCL</code>优点是资源利用率高，第一次执行<code>getInstance</code>时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。</p><h1 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h1><p><code>SingletonHolder</code> 是一个静态内部类，当外部类 <code>Singleton</code> 被加载的时候，并不会创建 <code>SingletonHolder</code> 实例对象。只有当调用 <code>getInstance()</code> 方法时，<code>SingletonHolder</code> 才会被加载，这个时候才会创建 <code>instance</code>。<code>instance</code> 的唯一性、创建过程的线程安全性，都由 <code>JVM</code> 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>单例的定义单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</li><li>单例的用处从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</li><li>单例的实现单例有下面几种经典的实现方式。</li></ol><ul><li> 饿汉式<br>饿汉式的实现方式，在类加载的期间，就已经将 <code>instance</code> 静态实例初始化好了，所以，<code>instance</code> 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</li><li>懒汉式<br>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</li><li>双重检测<br>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 <code>instance</code> 被创建之后，再调用 <code>getInstance()</code> 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</li><li>静态内部类<br>利用 <code>Java</code> 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</li><li>枚举<br>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 <code>Java</code> 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</li></ul><p>6种单例的实现代码见<a href="https://github.com/droidYu/DesignPattern/tree/main/app/src/main/java/com/droidyu/designpattern/singleton">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（八）深入剖析View的onMeasure方法</title>
      <link href="/android/view/8-view-measure/"/>
      <url>/android/view/8-view-measure/</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="https://droidyu.github.io/android/view/6-view-work-entrance/">《View体系（六）View工作流程入口》</a>介绍了<code>View</code>是从什么地方开始它的工作流程的，<a href="https://droidyu.github.io/android/view/7-view-MeasureSpec/">《View体系（七）理解 MeasureSpec》</a>介绍了<code>View</code>在<code>measure</code>流程时的一个重要参数。有了上两篇的铺垫，我们就来看一下<code>View</code>的<code>onMeasure</code>方法到底做了什么。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在<code>View</code>做测量时，会调用<code>View</code>的<code>onMeasure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只调用了一个<code>setMeasuredDimension</code>方法，看它的注释：</p><blockquote><p>This method must be called by {@link #onMeasure(int, int)} to store the measured width and measured height. </p></blockquote><p>可以知道，这个方法是用来存储测量的宽度和测量的高度的。</p><p>继续看<code>setMeasuredDimension</code>方法里面调用了<code>getDefaultSize</code>，该方法用于获取<code>View</code>默认的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;<span class="comment">//①</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>specMode</code>和<code>specSize</code>之前的文章中讲过，表示测量模式和测量大小。这段代码表示根据不同的<code>specMode</code>来返回不同的<code>result</code>值，即<code>View</code>测量的大小。可以看到注释<code>①</code>处不管是<code>AT_MOST</code>还是<code>EXACTLY</code>，都返回<code>specSize</code>，也就是说，对于一个直接继承自<code>View</code>的自定义<code>View</code>来说，它的<code>wrap_content</code>和<code>match_parent</code>属性的效果是一样的。因此我们自定义<code>View</code>时，如果要使<code>wrap_content</code>属性生效，就必须重写<code>onMeasure</code>方法并根据<code>specMode</code>来返回指定的大小。</p><p>现在我们知道了<code>specSize</code>是测量的大小，那传入的第一个参数<code>size</code>又是个什么？我们看传入的<code>getSuggestedMinimumWidth</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断<code>View</code>是否有背景，如果有，就返回背景宽度和<code>View</code>最小宽度中较大的一个；如果没有，就直接返回<code>View</code>的最小宽度，即<code>mMinWidth</code>。默认的<code>mMinWidth</code>为0，对应<code>xml</code>文件中的<code>android:minWidth</code>属性。</p><p>至此，<code>View</code>的<code>onMeasure</code>方法我们就分析完了，其做的工作很简单，就是保存<code>View</code>的测量尺寸。在我们自定义<code>View</code>时，我们根据自己的需求来重写<code>onMeasure</code>方法，并对<code>View</code>的尺寸自己进行测量并调用<code>setMeasuredDimension</code>方法进行保存。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Android系统启动过程</title>
      <link href="/android/framework/system-launch/"/>
      <url>/android/framework/system-launch/</url>
      
        <content type="html"><![CDATA[<p><code>Android</code>系统的启动流程是十分复杂的，但是作为应用层的开发人员来说，了解其大致流程即可。</p><h1 id="启动流程概览"><a href="#启动流程概览" class="headerlink" title="启动流程概览"></a>启动流程概览</h1><p><code>Android</code>系统启动流程大致可以概括为以下的几个步骤：</p><ol><li><p>启动电源及系统启动</p></li><li><p>引导程序<code>BootLoader</code>启动</p></li><li><p><code>Linux</code>内核启动</p></li><li><p><code>init</code>进程启动</p></li><li><p><code>Zygote</code>进程启动</p></li><li><p><code>SystemServer</code>进程启动</p></li><li><p><code>Launcher</code>启动</p></li></ol><h1 id="关键进程"><a href="#关键进程" class="headerlink" title="关键进程"></a>关键进程</h1><p>在介绍启动流程之前，先来了解一下几个关键的进程及其作用：</p><h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a><code>init</code>进程</h2><p><code>init</code>进程是<code>Android</code>系统中用户空间的第一个进程，进程号为<code>1</code>，是<code>Android</code>系统启动流程中的一个关键进程。它被赋予很多重要的工作职责，比如创建<code>Zygote</code>（孵化器）和属性服务等。<br><code>init</code>进程是由多个源文件组成的，这些文件位于源码目录<code>system/core/init</code>中。</p><h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a><code>Zygote</code>进程</h2><p>在<code>Android</code>系统中，<code>DVM</code>和<code>ART</code>、应用程序进程以及运行系统关键服务的<code>SystemServer</code>进程都是由<code>Zygote</code>进程来创建的，我们也可以将其称为孵化器。它通过<code>fork</code>（复制进程）的形式来创建应用程序进程和<code>SystemServer</code>进程。由于<code>Zygote</code>进程在启动时会创建<code>DVM</code>或<code>ART</code>，因此通过<code>fork</code>而创建的应用程序进程和<code>SystemServer</code>进程可以在内部获得一个<code>DVM</code>或<code>ART</code>的实例副本。</p><h2 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a><code>SystemServer</code>进程</h2><p><code>SystemServer</code>进程主要用于创建系统服务，我们熟悉的<code>AMS</code>、<code>WMS</code>和<code>PMS</code>都是由它来创建的。</p><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a><code>Launcher</code></h2><p><code>Launcher</code>是一个应用程序，用来显示系统中已经安装的应用程序。<code>Launcher</code>在启动过程中会请求<code>PMS</code>返回系统中已安装的应用程序信息，并将这些信息封装为一个快捷图标列表显示在系统屏幕上，用户可以点击这些图标来启动相应的应用程序。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><h2 id="1-启动电源及系统启动"><a href="#1-启动电源及系统启动" class="headerlink" title="1. 启动电源及系统启动"></a>1. 启动电源及系统启动</h2><p>当电源按下时，引导芯片代码从预定义的地方（固化在<code>ROM</code>中）开始执行。这里主要做的是加载引导程序<code>BootLoader</code>到<code>RAM</code>中，然后执行引导程序。</p><h2 id="2-引导程序BootLoader启动"><a href="#2-引导程序BootLoader启动" class="headerlink" title="2. 引导程序BootLoader启动"></a>2. 引导程序<code>BootLoader</code>启动</h2><p>引导程序<code>BootLoader</code>是在<code>Android</code>操作系统开始运行前到一小段程序，它的作用是把系统<code>OS</code>拉起来并运行。</p><h2 id="3-Linux内核启动"><a href="#3-Linux内核启动" class="headerlink" title="3. Linux内核启动"></a>3. <code>Linux</code>内核启动</h2><p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当<code>Linux</code>内核完成系统设置时，它首先在系统中寻找<code>init.rc</code>文件，并启动<code>init</code>进程。</p><h2 id="4-init进程启动"><a href="#4-init进程启动" class="headerlink" title="4. init进程启动"></a>4. <code>init</code>进程启动</h2><ul><li>创建和挂载启动所需的文件目录</li><li>初始化和启动属性服务</li><li>解析<code>init.rc</code>配置文件</li><li>启动<code>Zygote</code>进程</li></ul><h2 id="5-Zygote进程启动"><a href="#5-Zygote进程启动" class="headerlink" title="5. Zygote进程启动"></a>5. <code>Zygote</code>进程启动</h2><ul><li>创建<code>AppRuntime</code>并调用其<code>start</code>方法，启动<code>Zygote</code>进程</li><li>创建<code>Java</code>虚拟机并为其注册<code>JNI</code>方法</li><li>通过<code>JNI</code>调用<code>ZygoteInit</code>的<code>main</code>函数进入<code>Zygote</code>的<code>Java</code>框架层</li><li>通过<code>registerZygoteSocket</code>方法创建服务端<code>Socket</code>，并通过<code>runSelectLoop</code>方法等待<code>AMS</code>的请求来创建新的应用程序进程。</li></ul><h2 id="6-SystemServer进程启动"><a href="#6-SystemServer进程启动" class="headerlink" title="6. SystemServer进程启动"></a>6. <code>SystemServer</code>进程启动</h2><ul><li>启动<code>Binder</code>线程池，用于后续与其他进程进行通信</li><li>创建<code>SystemServiceManager</code>，用于对系统服务进行创建、启动和管理。</li><li>启动各种系统服务<h2 id="7-Launcher启动"><a href="#7-Launcher启动" class="headerlink" title="7. Launcher启动"></a>7. <code>Launcher</code>启动</h2></li></ul><p>被<code>SystemServer</code>进程启动的AMS会启动<code>Launcher</code>，<code>Launcher</code>启动后会将已安装应用的图标显示到界面上。</p><p>结合上面的流程，给出<code>Android</code>系统启动流程图：<br><img src="https://pic.imgdb.cn/item/62038ad72ab3f51d912547a8.jpg"></p><p>参考资料：《Android进阶解密》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android系统启动 </tag>
            
            <tag> Android Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（七）理解 MeasureSpec</title>
      <link href="/android/view/7-view-MeasureSpec/"/>
      <url>/android/view/7-view-MeasureSpec/</url>
      
        <content type="html"><![CDATA[<p><code>MeasureSpec</code>是<code>View</code>的内部类，<code>MeasureSpec</code> 封装了从父级传递到子级的测量要求。每个 <code>MeasureSpec</code> 代表对宽度或高度的要求。 <code>MeasureSpec</code> 由大小和模式两部分组成。</p><p>更详细的说明请看 <a href="https://developer.android.google.cn/reference/android/view/View.MeasureSpec">Google官方文档</a></p><p>下面是<code>MeasureSpec</code>的源码：<strong>（基于<a href="https://github.com/droidYu/platform_frameworks_base/blob/android12-release/core/java/android/view/View.java"><code>Android 12</code></a>）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="meta">@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1)</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="meta">@MeasureSpecMode</span> <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        size += delta;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Log.e(VIEW_LOG_TAG, <span class="string">&quot;MeasureSpec.adjust: new size would be negative! (&quot;</span> + size +</span><br><span class="line">                    <span class="string">&quot;) spec: &quot;</span> + toString(measureSpec) + <span class="string">&quot; delta: &quot;</span> + delta);</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;MeasureSpec: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED)</span><br><span class="line">            sb.append(<span class="string">&quot;UNSPECIFIED &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == EXACTLY)</span><br><span class="line">            sb.append(<span class="string">&quot;EXACTLY &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == AT_MOST)</span><br><span class="line">            sb.append(<span class="string">&quot;AT_MOST &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sb.append(mode).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(size);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，它代表了32位<code>int</code>值，其中高2位代表<code>mode</code>，低30位代表<code>size</code>。<code>mode</code>指测量模式，<code>size</code>指测量值。<code>mode</code>有3种模式：</p><ul><li><p><code>UNSPECIFIED</code>：未指定模式，父<code>View</code>没有对子<code>View</code>施加任何限制。它可以是任何它想要的大小。</p></li><li><p><code>EXACTLY</code>：精确模式，父<code>View</code>已经确定了子<code>View</code>的确切尺寸。无论子<code>View</code>想要多大，都将获得这些界限。</p></li><li><p><code>AT_MOST</code>：最大模式，子<code>View</code>可以根据需要达到指定的最大的大小。</p></li></ul><p><code>makeMeasureSpec</code>用来保存宽和高的信息，<code>getMode</code>用来获取测量模式，<code>getSize</code>用来获取测量大小。</p><p><code>MeasureSpec</code>受自身<code>LayoutParams</code>和父<code>View</code>的<code>MeasureSpec</code>共同影响。作为顶层<code>View</code>的<code>DecorView</code>来说，其并没有父<code>View</code>，那它的<code>MeasureSpec</code>是如何得来的呢？我们回到<code>ViewRootImpl</code>的<code>performTraversals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mStopped || wasReportNextDraw) &#123;</span><br><span class="line"><span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">        || mHeight != host.getMeasuredHeight() || dispatchApplyInsets ||</span><br><span class="line">        updatedConfiguration) &#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">&quot;Ooops, something changed!  mWidth=&quot;</span></span><br><span class="line">            + mWidth + <span class="string">&quot; measuredWidth=&quot;</span> + host.getMeasuredWidth()</span><br><span class="line">            + <span class="string">&quot; mHeight=&quot;</span> + mHeight</span><br><span class="line">            + <span class="string">&quot; measuredHeight=&quot;</span> + host.getMeasuredHeight()</span><br><span class="line">            + <span class="string">&quot; dispatchApplyInsets=&quot;</span> + dispatchApplyInsets);</span><br><span class="line"></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>再看注释1处的<code>getRootMeasureSpec</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数<code>windowSize</code>指窗口的尺寸，所以对于<code>DecorView</code>来说，它的<code>MeasureSpec</code>由自身的<code>LayoutParams</code>和窗口的尺寸决定，这一点和普通的<code>View</code>是不同的。<br>再回到上面看注释2处的<code>performMeasure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处调用了<code>mView.measure</code>方法，进入了<code>view</code>的<code>measure</code>流程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（六）View工作流程入口</title>
      <link href="/android/view/6-view-work-entrance/"/>
      <url>/android/view/6-view-work-entrance/</url>
      
        <content type="html"><![CDATA[<p><code>View</code>的工作流程，就是<code>View</code>进行<code>measure</code>、<code>layout</code>和<code>draw</code>的过程，本篇文章我们就来一起看一下<code>View</code>是如何开始他的工作流程的。</p><blockquote><p><strong>（注：文中源码基于 <code>Android 12</code>）</strong></p></blockquote><p>在上篇文章<a href="https://droidyu.github.io/android/view/5-setContentView/">《View体系（五）熟悉又陌生的setContentView》</a>中我们讲过<code>Activity</code>的结构，包括了<code>Activity</code>、<code>PhoneWindow</code>及<code>DecorView</code>。讲了<code>PhoneWindow</code>的创建和<code>DecorView</code>的创建，但此时<code>DecorView</code>还没有加载到<code>PhoneWindow</code>中，下面我们就从源码看一下<code>DecorView</code>是如何加载到<code>PhoneWindow</code>中的。</p><p>当我们调用<code>Activity</code>的<code>startActivity</code>时，最终会调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>，代码如下：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<span class="comment">//1</span></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>注释1处调用<code>performLaunchActivity</code>创建了一个<code>Activity</code>，进入<code>performLaunchActivity</code>方法：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">Activity activity = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);<span class="comment">//1</span></span><br><span class="line">...                </span><br><span class="line">activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken, r.shareableActivityToken);<span class="comment">//2</span></span><br><span class="line">...                    </span><br><span class="line">mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<span class="comment">//3</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> activity;</span><br></pre></td></tr></table></figure><p>注释1处会通过<code>mInstrumentation</code>的<code>newActivity</code>方法，使用反射的方式，创建<code>Activity</code>的实例，注释2处调用<code>activity.attach</code>方法，在之前的文章中讲过，<code>attach</code>会创建<code>PhoneWindow</code>实例，并赋值给传入的<code>window</code>引用，注释3处最终会调用<code>Activity</code>的<code>OnCreate</code>回调方法，进而调用<code>setContentView</code>方法，创建<code>DecorView</code>。</p><p>在<code>Android12</code>的源码中，<code>handleLaunchActivity</code>方法中并不会直接调用<code>handleResumeActivity</code>方法，而是通过<code>ClientTransaction</code>类来实现调用<code>handleLaunchActivity</code>之后再调用<code>handleResumeActivity</code>，具体的放在后面的文章中讲解。</p><p>我们继续看<code>handleResumeActivity</code>方法：</p><blockquote><p>android.app.ActivityThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();<span class="comment">//1</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();<span class="comment">//2</span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    wm.addView(decor, l);<span class="comment">//3</span></span><br><span class="line">                    ...</span><br></pre></td></tr></table></figure><p>注释1处得到了<code>DecorView</code>，注释2处得到了<code>WindowManager</code>对象，注释3处调用<code>WindowManager</code>的<code>addView</code>方法，将<code>DecorView</code>作为参数传入，<code>WindowManager</code>的实现类是<code>WindowManagerImpl</code>，所以实际调用的是<code>WindowManagerImpl</code>的<code>addView</code>方法。再看<code>WindowManagerImpl</code>的<code>addView</code>方法：</p><blockquote><p>android.view.WindowManagerImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyTokens(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处又调用了<code>WindowManagerGlobal</code>的<code>addView</code>方法：</p><blockquote><p>android.view.WindowManagerGlobal</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="params"><span class="function">        Display display, Window parentWindow, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    ...</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    root.setView(view, wparams, panelParentView, userId);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注释1处创建了<code>ViewRootImpl</code>实例赋值给<code>root</code>，注释2处将<code>DecorView</code>作为参数传入<code>ViewRootImpl</code>，完成了<code>DecorView</code>和<code>Window</code>的绑定。</p><p><code>ViewRootImpl</code>中还有个方法<code>performTraversals</code>，这个方法使<code>View</code>进入正真的工作流程：</p><blockquote><p>android.view.ViewRootImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    performLayout(lp, mWidth, mHeight);<span class="comment">//2</span></span><br><span class="line">    ...</span><br><span class="line">    performDraw();<span class="comment">//3</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>注释1处会执行<code>view</code>的<code>Measure</code>过程，注释2处会执行<code>view</code>的<code>Layout</code>过程，注释3处会执行<code>view</code>的<code>Draw</code>过程。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（五）熟悉又陌生的setContentView</title>
      <link href="/android/view/5-setContentView/"/>
      <url>/android/view/5-setContentView/</url>
      
        <content type="html"><![CDATA[<p>为什么说<code>setContentView</code>熟悉呢？因为该方法是我们从入门Android开发就接触的一个方法，在我们写过的每一个<code>Activity</code>中都有他的身影。但为什么又说<code>setContentView</code>陌生呢？因为我们在日常的开发中只知道用，并没有深入分析该方法是怎么将我们传入的<code>layout</code>资源<code>id</code>变为一个可视的界面的。今天我们就来揭开这层神秘的面纱，扒一扒其中的原理(<strong>注：源码基于Android12</strong>)。</p><p>因为我们日常开发的<code>Activity</code>最终都会继承自<code>android.app.Activity</code>，所以先看<code>Activity</code>类的<code>setContentView</code>方法：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID); <span class="comment">//1</span></span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释1处其实是调用了<code>getWindow()</code>的<code>setContentView</code>方法，我们再看<code>getWindow()</code>做了什么。</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回了一个<code>mWindow</code>，那<code>mWindow</code>又是什么，看他的声明代码：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> Window mWindow;</span><br></pre></td></tr></table></figure><p><code>mWindow</code>是一个<code>Window</code>类，查看源码在<code>Activity</code>的<code>attach</code>方法中<code>mWindow</code>被赋值：</p><blockquote><p>android.app.Activity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="params"><span class="function">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="params"><span class="function">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="params"><span class="function">            CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="params"><span class="function">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="params"><span class="function">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="params"><span class="function">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,</span></span></span><br><span class="line"><span class="params"><span class="function">            IBinder shareableActivityToken)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">        mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>看到这里，我们知道<code>Activity</code>的<code>setContentView</code>最终调用的是<code>PhoneWindow</code>的<code>setContentView</code>方法，我们继续看<code>PhoneWindow</code>的<code>setContentView</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释1处的<code>installDecor</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDecor = generateDecor(-<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">            mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mContentParent = generateLayout(mDecor);<span class="comment">//2</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>看注释1处的<code>generateDecor</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateDecor</code>最终<code>new</code>了一个<code>DecorView</code>对象，并把该对象返回并赋值给<code>installDecor</code>方法中的<code>mDecor</code>引用。</p><p>返回到<code>installDecor</code>方法继续看注释2的<code>generateLayout</code>方法：</p><blockquote><p>com.android.internal.policy.PhoneWindow</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    ...</span><br><span class="line">    layoutResource = R.layout.screen_title;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br></pre></td></tr></table></figure><p>由于<code>generateLayout</code>的代码很长，此处只贴出关键的代码。<code>generateLayout</code>的主要工作是将系统中的<code>R.layout.screen_title</code>布局资源添加到<code>DecorView</code>中，然后在<code>PhoneWindow</code>中调用<code>findViewById(ID_ANDROID_CONTENT)</code>，找到<code>R.layout.screen_title</code>中<code>id</code>为<code>ID_ANDROID_CONTENT</code>的<code>FrameLayout</code>，并返回给<code>installDecor</code>方法中的<code>mContentParent</code>引用。<br><code>R.layout.screen_title</code>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;?android:attr/windowTitleSize&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleBackgroundStyle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/title&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleStyle&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fadingEdge</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dip&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意最下面的<code>FrameLayout</code>的<code>id</code>是为：<code>content</code>，再看源码中的<code>ID_ANDROID_CONTENT</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID_ANDROID_CONTENT = com.android.internal.R.id.content;</span><br></pre></td></tr></table></figure><p>最后再回到<code>PhoneWindow</code>的<code>setContentView</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的代码之前已经讲完了，然后看注释2处的代码，这句代码就是将<code>setContentView</code>传入的布局资源<code>id</code>加载到<code>mContentParent</code>，而<code>mContentParent</code>就是之前讲过的<code>id</code>为<code>content</code>的<code>FrameLayout</code>。</p><p>至此一个<code>Activity</code>的结构也清楚了，结构如下图所示：</p><p><img src="https://pic.imgdb.cn/item/61efb07a2ab3f51d915e2ede.jpg"></p><p><code>Activity</code>中包含一个<code>PhoneWindow</code>，<code>PhoneWindow</code>中包含一个<code>DecorView</code>，<code>DecorView</code>中包含系统的布局资源<code>R.layout.screen_title</code>。而<code>setContentView</code>就是将在<code>Activity</code>中传入的布局资源文件加载到<code>id</code>为<code>content</code>的<code>FrameLayout</code>中。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（四）深入理解事件分发机制</title>
      <link href="/android/view/4-event-2/"/>
      <url>/android/view/4-event-2/</url>
      
        <content type="html"><![CDATA[<p>上篇文章<a href="https://droidyu.github.io/android/view/3-event/">《View体系（三）初探View事件分发机制》</a>对View的事件分发机制进行了粗略的讲解，并用代码实际探究了View事件的传递和处理过程。这篇文章就对View的事件分发机制进行一个更深入的讲解。<br>之前提到过事件分发机制中的三个方法：<code>dispatchTouchEvent(MotionEvent event)</code>、<code>onInterceptTouchEvent(MotionEvent ev)</code>和<code>onTouchEvent(MotionEvent event)</code>，那么这三个方法到底有什么样的关联呢？他们的关系其实可以用如下的伪代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">        result = onTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件由上到下的传递规则"><a href="#事件由上到下的传递规则" class="headerlink" title="事件由上到下的传递规则"></a>事件由上到下的传递规则</h1><p>对于根<code>ViewGroup</code>，事件首先传递给它的<code>dispatchTouchEvent()</code>方法，如果该<code>ViewGroup</code>的<code>onInterceptTouchEvent()</code>方法返回<code>true</code>，则表示它要拦截这个事件，这个事件就会交给它的<code>onTouchEvent()</code>方法处理，如果<code>onInterceptTouchEvent()</code>方法返回<code>false</code>，则表示它不拦截这个事件，则交给它的子元素的<code>dispatchTouchEvent()</code>来处理，如此的反复下去。如果传递给最底层的<code>View</code>，<code>View</code>是没有子<code>View</code>的，就会调用<code>View</code>的<code>dispatchTouchEvent()</code>方法，一般情况下最终会调用<code>View</code>的<code>onTouchEvent()</code>方法。</p><p>类比生活中的场景：假如你只是公司的基层员工(<code>View</code>),部门经理(父<code>ViewGroup</code>)通常会将事情(<code>MotionEvent</code>)安排给项目经理(子<code>ViewGroup</code>)，项目经理再将事情安排给你。如果项目经理觉得他自己就能处理部门经理安排的事情，他就会把事情拦截(<code>onInterceptTouchEvent</code>)，然后自己处理(<code>onTouchEvent</code>)，不再安排给你处理。</p><h1 id="事件由下而上的传递规则"><a href="#事件由下而上的传递规则" class="headerlink" title="事件由下而上的传递规则"></a>事件由下而上的传递规则</h1><p>事件传给最底层的<code>View</code>，如果他的<code>onTouchEvent()</code>方法返回<code>true</code>，则事件由最底层的<code>View</code>处理并消耗了，如果返回<code>false</code>则表示该<code>View</code>不消耗此次事件，则继续向上传递给父<code>View</code>的<code>onTouchEvent()</code>处理，如果父<code>View</code>的<code>onTouchEvent()</code>仍旧返回<code>false</code>，则继续向上传递给该父<code>View</code>的父<code>View</code>的<code>onTouchEvent()</code>处理，如此的反复下去。</p><p>同样类比上述场景：你把事情处理好了(<code>onTouchEvent</code>返回<code>true</code>)，那么事情就完结了；如果你处理不了(<code>onTouchEvent</code>返回<code>false</code>)，就需要上交给项目经理处理(传递给子<code>ViewGroup</code>的<code>onTouchEvent</code>)，如果项目经理也处理不了，就需要再向上交给部门经理处理(传递给父<code>ViewGroup</code>的<code>onTouchEvent</code>)。</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（三）初探View事件分发机制</title>
      <link href="/android/view/3-event/"/>
      <url>/android/view/3-event/</url>
      
        <content type="html"><![CDATA[<p>事件分发机制，简而言之就是Android对触摸事件的一系列传递和处理的机制。在了解分发机制之前需要对下面三个方法有个大概的了解：</p><ul><li><code>public boolean dispatchTouchEvent(MotionEvent event)</code></li></ul><p>用来进行事件的分发。如果有事件传递给当前<code>View</code>，那么此方法一定会被调用。返回值受当前View的<code>onTouchEvent(MotionEvent event)</code>和子<code>View</code>的<code>dispatchTouchEvent(MotionEvent event)</code>方法的影响，表示是否消耗当前事件。</p><ul><li><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></li></ul><p>用来判断是否拦截事件，返回值表示是否拦截当前事件。</p><ul><li><code>public boolean onTouchEvent(MotionEvent event)</code></li></ul><p>用来处理事件，返回值表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前<code>View</code>无法再次接收到事件。</p><p>我们知道Android的<code>View</code>结构是树状结构的，<code>View</code>可以放在一个<code>ViewGroup</code>里，这个<code>ViewGroup</code>又可以放在一个<code>ViewGroup</code>里，那么当我们点击一个嵌套的结构，事件传递是怎样的呢？<br>为此，我们用代码来实现一下。</p><p>1.创建<code>BaseViewGroup</code>作为底层<code>ViewGroup</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseViewGroup</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseViewGroup</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-onInterceptTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;BaseViewGroup-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建<code>TopViewGroup</code>作为顶层<code>ViewGroup</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopViewGroup</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopViewGroup</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-onInterceptTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;TopViewGroup-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建<code>MyView</code>作为最上层的<code>View</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;MyView-dispatchTouchEvent-&quot;</span>+ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;ViewEvent&quot;</span>, <span class="string">&quot;MyView-onTouchEvent-&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.布局自定义<code>View</code>及<code>ViewGroup</code>，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.BaseViewGroup</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#1f1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;._3_event.ViewEventActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.TopViewGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#ff1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.droidyu.viewsystem._3_event.MyView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;#f11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.droidyu.viewsystem._3_event.TopViewGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.droidyu.viewsystem._3_event.BaseViewGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终，视图结构如下所示：<br><img src="https://pic.imgdb.cn/item/61f3e5de2ab3f51d91264e07.png"></p><p>运行程序，点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3efef2ab3f51d9131f00c.jpg"><br>从<code>Log</code>日志可以看出，正常情况下，<br>事件的传递顺序是：<br><code>BaseViewGroup</code> -&gt; <code>TopViewGroup</code> -&gt; <code>MyView</code> 的<code>dispatchTouchEvent</code>和<code>onInterceptTouchEvent</code>方法<br>事件处理顺序是：<br><code>MyView</code> -&gt; <code>TopViewGroup</code> -&gt; <code>BaseViewGroup</code> 的<code>onTouchEvent</code>方法</p><p>此时将<code>BaseViewGroup</code>的<code>onInterceptTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0262ab3f51d91323696.jpg"><br>从<code>Log</code>日志可以看出，<code>BaseViewGroup</code>拦截事件之后，就直接处理事件，不会再将事件向子<code>View</code>传递。</p><p>还原代码，将<code>TopViewGroup</code>的<code>onInterceptTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f04c2ab3f51d913266fb.jpg"><br>从<code>Log</code>日志可以看出，事件从<code>BaseViewGroup</code>传递到<code>TopViewGroup</code>，<code>TopViewGroup</code>拦截事件之后，就直接处理事件，不会再将事件向子<code>View</code>传递，处理后会不消耗，返回给<code>BaseViewGroup</code>再处理。</p><p>还原代码，将<code>MyView</code>的<code>onTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0952ab3f51d9132c2af.jpg"><br>从<code>Log</code>日志可以看出，事件传递到<code>MyView</code>，<code>MyView</code>处理事件之后，就不再向上传递。</p><p>还原代码，将<code>TopViewGroup</code>的<code>onTouchEvent</code>返回值改为<code>true</code>，再次点击红色的<code>MyView</code>，然后查看<code>Log</code>日志如下：<br><img src="https://pic.imgdb.cn/item/61f3f0e62ab3f51d913323f9.jpg"><br>从<code>Log</code>日志可以看出，事件传递到<code>MyView</code>，<code>MyView</code>处理事件之后，又向上传递到<code>TopViewGroup</code>处理，<code>TopViewGroup</code>处理事件之后，就不再向上传递。</p><p>至此相信你对<code>View</code>的事件传递和处理有了一个更直观的认识，更多的讲解将在后续文章中更新，敬请期待。。。</p><p>源码见<a href="https://github.com/droidYu/view-system">Github</a></p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（二）View滑动的六种方式</title>
      <link href="/android/view/2-scroll/"/>
      <url>/android/view/2-scroll/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，有时会遇到需要对View进行滑动处理的情况，今天我们就一起来看一下如何实现View的滑动。</p><p>不管采用什么方式，实现思路基本是一致的：当触摸到View时，记下当前触摸点的坐标；当手指移动时，记下移动后触摸点的坐标，然后用两个坐标算出移动的偏移量，再利用偏移量来修改View的坐标。</p><p>下面分别来讲解实现View滑动的6种方式。</p><h1 id="一、layout"><a href="#一、layout" class="headerlink" title="一、layout()"></a>一、layout()</h1><p><code>layout()</code>方法是View在进行布局流程时调用的一个方法，我们可以在移动View时调用次方法，不断的进行View的布局，达到滑动View的目的。具体过程如下：</p><p>（1）先自定义一个View，重写<code>onTouchEvent(MotionEvent event)</code>方法，在<code>ACTION_DOWN</code>时获取按下时的坐标。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>（2）在手指移动时，计算偏移量并调用<code>layout()</code>方法进行重新布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">                <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">                way1(offsetX, offsetY);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中<code>way1()</code>方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way1</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    layout(getLeft() + offsetX,</span><br><span class="line">            getTop() + offsetY,</span><br><span class="line">            getRight() + offsetX,</span><br><span class="line">            getBottom() + offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、offsetLeftAndRight-与offsetTopAndBottom"><a href="#二、offsetLeftAndRight-与offsetTopAndBottom" class="headerlink" title="二、offsetLeftAndRight()与offsetTopAndBottom()"></a>二、offsetLeftAndRight()与offsetTopAndBottom()</h1><p>这两个方法的使用与效果和<code>layout()</code>方法差不多，将<code>ACTION_MOVE</code>中的代码替换为<code>way2()</code>即可，其中<code>way2()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way2</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    offsetLeftAndRight(offsetX);</span><br><span class="line">    offsetTopAndBottom(offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、LayoutParams"><a href="#三、LayoutParams" class="headerlink" title="三、LayoutParams"></a>三、LayoutParams</h1><p><code>LayoutParams</code>保存了View的布局参数，因此我们可以通过改变布局参数的值来改变View的位置。将<code>ACTION_MOVE</code>中的代码替换为<code>way3_1()</code>即可，其中<code>way3_1()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way3_1</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">    layoutParams.leftMargin = getLeft() + offsetX;</span><br><span class="line">    layoutParams.topMargin = getTop() + offsetY;</span><br><span class="line">    setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为父控件是<code>LinearLayout</code>，所以用了<code>LinearLayout.LayoutParams</code>，除了使用布局的<code>LayoutParams</code>，还可以使用<code>ViewGroup.MarginLayoutParams</code>来改变View的位置。将<code>ACTION_MOVE</code>中的代码替换为<code>way3_2()</code>即可，其中<code>way3_2()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way3_2</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();</span><br><span class="line">    layoutParams.leftMargin = getLeft() + offsetX;</span><br><span class="line">    layoutParams.topMargin = getTop() + offsetY;</span><br><span class="line">    setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、scrollTo与scrollBy"><a href="#四、scrollTo与scrollBy" class="headerlink" title="四、scrollTo与scrollBy"></a>四、scrollTo与scrollBy</h1><p><code>scollTo(x,y)</code>表示移动到一个具体的坐标点，而<code>scollBy(dx,dy)</code>则表示移动的增量为<code>dx</code>、<code>dy</code>。其中<code>scollBy</code>最终也是要调用<code>scollTo</code>的。<code>scollTo</code>、<code>scollBy</code>移动的是View的内容，如果在ViewGroup中使用则是移动他所有的子View。将<code>ACTION_MOVE</code>中的代码替换为<code>way4()</code>即可，其中<code>way4()</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">way4</span><span class="params">(<span class="keyword">int</span> offsetX, <span class="keyword">int</span> offsetY)</span> </span>&#123;</span><br><span class="line">    ((View) getParent()).scrollBy(-offsetX, -offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要实现View随着我们手指移动的效果的话，我们就需要将偏移量设置为负值。</p><h1 id="五、Scroller"><a href="#五、Scroller" class="headerlink" title="五、Scroller"></a>五、Scroller</h1><p><code>Scroller</code>本身是不能实现View的滑动的，它需要配合View的<code>computeScroll()</code>方法才能弹性滑动的效果。</p><h2 id="（1）初始化Scroller"><a href="#（1）初始化Scroller" class="headerlink" title="（1）初始化Scroller"></a>（1）初始化<code>Scroller</code></h2><p>在构造函数中初始化<code>Scroller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyScrollView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    scroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（2）重写computeScroll"><a href="#（2）重写computeScroll" class="headerlink" title="（2）重写computeScroll()"></a>（2）重写<code>computeScroll()</code></h2><p>系统会在绘制View的时候在<code>draw()</code>方法中调用该方法，这个方法中我们调用父类的<code>scrollTo()</code>方法并通过<code>Scroller</code>来不断获取当前的滚动值，每滑动一小段距离我们就调用<code>invalidate()</code>方法不断的进行重绘，重绘就会调用<code>computeScroll()</code>方法，这样我们就通过不断的移动一个小的距离并连贯起来就实现了平滑移动的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">        ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY());</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（3）调用Scroller-startScroll-方法"><a href="#（3）调用Scroller-startScroll-方法" class="headerlink" title="（3）调用Scroller.startScroll()方法"></a>（3）调用<code>Scroller.startScroll()</code>方法</h2><p>我们在<code>MyScrollView</code>中写一个<code>smoothScrollTo()</code>方法，调用<code>Scroller.startScroll()</code>方法，在<code>2000</code>毫秒内沿X轴和Y轴移动x和y个像素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> scrollY = getScrollY();</span><br><span class="line">    <span class="keyword">int</span> offsetX = scrollX - x;</span><br><span class="line">    <span class="keyword">int</span> offsetY = scrollY - y;</span><br><span class="line">    scroller.startScroll(scrollX, scrollY, offsetX, offsetY, <span class="number">2000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（4）调用MyScrollView的smoothScrollTo-方法"><a href="#（4）调用MyScrollView的smoothScrollTo-方法" class="headerlink" title="（4）调用MyScrollView的smoothScrollTo()方法"></a>（4）调用<code>MyScrollView</code>的<code>smoothScrollTo()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.smoothScrollTo(<span class="number">200</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><h1 id="六、属性动画"><a href="#六、属性动画" class="headerlink" title="六、属性动画"></a>六、属性动画</h1><p>最后就是定义一个属性动画进行View的滑动，属性动画的具体使用将放在后续章节中进行讲解，这里直接贴出实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">&quot;translationX&quot;</span>, <span class="number">400</span>);</span><br><span class="line">animator.setDuration(<span class="number">2000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><p>源码见<a href="https://github.com/droidYu/view-system/tree/main/app/src/main/java/com/droidyu/viewsystem/_2_scroll">Github</a></p><p>参考文献：<br>《Android进阶之光》<br>《Android开发艺术探索》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View体系（一）基础知识</title>
      <link href="/android/view/1-basic/"/>
      <url>/android/view/1-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="View-及ViewGroup"><a href="#View-及ViewGroup" class="headerlink" title="View 及ViewGroup"></a>View 及ViewGroup</h1><p>在Android中，常用控件可大致分为两大类：<code>View</code>与<code>ViewGroup</code>。<code>ViewGroup</code>可包含多个<code>View</code>及<code>ViewGroup</code>，形成一个树状结构。需要注意的是<code>ViewGroup</code>也继承自<code>View</code>。View及ViewGroup组织结构如下：<br><img src="https://pic.imgdb.cn/item/61f22a542ab3f51d91780c5e.png"></p><h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><p>在Android中有两种坐标系：Android坐标系和View坐标系。了解坐标系是对View进行更多操作的基础。</p><h2 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h2><p>以屏幕左上角为原点，原点向右为<code>X</code>轴正方向，原点向下为<code>Y</code>轴正方向。在触控事件中，<code>getRawX()</code>、<code>getRawY()</code>获取的坐标也是Android坐标系的坐标。</p><p><img src="https://pic.imgdb.cn/item/61efa6722ab3f51d91557262.jpg"></p><h2 id="View坐标系"><a href="#View坐标系" class="headerlink" title="View坐标系"></a>View坐标系</h2><p>View坐标系是以View为基础的坐标系，搞清楚下图的关系也就清楚了View坐标系。<br><img src="https://pic.imgdb.cn/item/61efa6802ab3f51d91557ee0.jpg"></p><p>下面解释一下上图中涉及到的各个方法。<br>其中下面4个方法可在View中直接获取：</p><ul><li><code>getTop()</code>：获取View顶边到父View顶边的距离</li><li><code>getBottom()</code>：获取View底边到父View顶边的距离</li><li><code>getLeft()</code>：获取View左边到父View左边的距离</li><li><code>getRight()</code>：获取View右边到父View左边的距离</li></ul><p>剩余4个方法需要在View有触摸事件发生时，通过onTouchEvent(MotionEvent event)方法中的event获取：</p><ul><li><code>getX()</code>：触摸点到View左边的距离</li><li><code>getY()</code>：触摸点到View顶边的距离</li><li><code>getRawX()</code>：触摸点到屏幕左边的距离</li><li><code>getRawY()</code>：触摸点到屏幕顶边的距离</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top = getTop();</span><br><span class="line">    <span class="keyword">int</span> bottom = getBottom();</span><br><span class="line">    <span class="keyword">int</span> left = getLeft();</span><br><span class="line">    <span class="keyword">int</span> right = getRight();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        <span class="keyword">float</span> rawX = event.getRawX();</span><br><span class="line">        <span class="keyword">float</span> rawY = event.getRawY();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码见<a href="https://github.com/droidYu/view-system/tree/main/app/src/main/java/com/droidyu/viewsystem/_1_basic">Github</a></p><p>参考文献：<br>《Android进阶之光》<br>《Android开发艺术探索》</p><blockquote><p><strong>关注我</strong></p><ul><li>掘金：<a href="https://juejin.cn/user/2365804752143256">droidYu</a></li><li>CSDN：<a href="https://blog.csdn.net/u010444082">droidYu</a></li><li>Github：<a href="https://github.com/droidYu">droidYu</a></li><li>个人博客：<a href="https://droidyu.github.io/">droidYu</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View体系 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
